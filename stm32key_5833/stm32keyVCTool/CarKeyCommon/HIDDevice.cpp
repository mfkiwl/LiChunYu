// HIDDevice.cpp : 实现文件
//

#include "stdafx.h"
#ifdef CarKey2
#include ".\..\CarKey2\CarKey2\resource.h"
#else
#include ".\..\CarKey3\CarKey3\resource.h"
#endif
#include "HIDDevice.h"
#include "InteractionData.h"
#include "CommFunc.h"
extern "C" {
	// This file is in the Windows DDK available from Microsoft.
#include "hidsdi.h"
#include "dbt.h"
#include <setupapi.h>
#include "PassCalc.h"
}
// CHIDDevice

IMPLEMENT_DYNAMIC(CHIDDevice, CWnd)

CHIDDevice::CHIDDevice()
{
	MyDeviceDetected=FALSE;
	VendorID=0x03d8;
	ProductID=0x000d;
	m_pProgress=NULL;
}

CHIDDevice::~CHIDDevice()
{
}


BEGIN_MESSAGE_MAP(CHIDDevice, CWnd)
END_MESSAGE_MAP()


bool CHIDDevice::FindDevice()
{
	GUID HidGuid;
	//取得类别
	HidD_GetHidGuid(&HidGuid);	
	//获取一个设备信息群，包含指定类的所有设备
	HANDLE hDevInfo;
	hDevInfo = SetupDiGetClassDevs(
		&HidGuid,
		NULL,
		NULL,
		DIGCF_PRESENT | DIGCF_INTERFACEDEVICE
		);
	SP_DEVICE_INTERFACE_DATA devInfoData;
	devInfoData.cbSize = sizeof(devInfoData);
	int MemberIndex = 0;
	bool LastDevice = FALSE;
	LONG Result;
	ULONG Length;
	PSP_DEVICE_INTERFACE_DETAIL_DATA detailData;
	ULONG Required;
	HIDD_ATTRIBUTES Attributes;
	do
	{
		Result=SetupDiEnumDeviceInterfaces(
			hDevInfo,
			0,
			&HidGuid,
			MemberIndex,
			&devInfoData
			);

		if (Result != 0)
		{			
			Result = SetupDiGetDeviceInterfaceDetail 
				(hDevInfo, 
				&devInfoData, 
				NULL, 
				0, 
				&Length, 
				NULL);

			detailData = (PSP_DEVICE_INTERFACE_DETAIL_DATA)malloc(Length);
			detailData -> cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
			//获取信息群内一个设备的信息
			Result = SetupDiGetDeviceInterfaceDetail 
				(hDevInfo, 
				&devInfoData, 
				detailData, 
				Length, 
				&Required, 
				NULL);
			DeviceHandle=CreateFile 
				(detailData->DevicePath, 
				0, 
				FILE_SHARE_READ|FILE_SHARE_WRITE, 
				(LPSECURITY_ATTRIBUTES)NULL,
				OPEN_EXISTING, 
				0, 
				NULL);
			Attributes.Size = sizeof(Attributes);

			//获取厂商与产品，版本号
			Result = HidD_GetAttributes 
				(DeviceHandle, 
				&Attributes
				);
			MyDeviceDetected = FALSE;

			if( (Attributes.VendorID == VendorID) && (Attributes.ProductID == ProductID))
			{
				MyDeviceDetected = TRUE;
// 				USB路径代表它的名字，用于拔插设备时显示
// 								MyDevicePathName = detailData->DevicePath;	
// 				
// 								//Register to receive device notifications.
// 				
// 								RegisterForDeviceNotifications();
				PHIDP_PREPARSED_DATA	PreparsedData;	//struct
				//获取保存设备能力信息的缓冲器的句柄
				HidD_GetPreparsedData(DeviceHandle, &PreparsedData);
				HIDP_CAPS Capabilities;
				HidP_GetCaps(PreparsedData, &Capabilities);
				OutputReportByteLength=Capabilities.OutputReportByteLength;
				InputReportByteLength=Capabilities.InputReportByteLength;
				HidD_FreePreparsedData(PreparsedData);
				//DeviceUsage = (Capabilities.UsagePage * 0x100) + Capabilities.Usage;

				// Get a handle for writing Output reports.

				WriteHandle=CreateFile 
					(detailData->DevicePath, 
					GENERIC_WRITE, 
					FILE_SHARE_READ|FILE_SHARE_WRITE, 
					(LPSECURITY_ATTRIBUTES)NULL,
					OPEN_EXISTING, 
					0, 
					NULL);
				ReadHandle=CreateFile 
					(detailData->DevicePath, 
					GENERIC_READ, 
					FILE_SHARE_READ|FILE_SHARE_WRITE,
					(LPSECURITY_ATTRIBUTES)NULL, 
					OPEN_EXISTING, 
					FILE_FLAG_OVERLAPPED, 
					NULL);
				if (hEventObject == NULL)	//0
				{
					hEventObject = CreateEvent 
						(NULL, 
						TRUE, 
						TRUE, 
						_T(""));
					HIDOverlapped.hEvent = hEventObject;
					HIDOverlapped.Offset = 0;
					HIDOverlapped.OffsetHigh = 0;
				}
			}
			else
			{
				CloseHandle(DeviceHandle);
				DeviceHandle=INVALID_HANDLE_VALUE;
			}
			free(detailData);
		} //if (Result != 0)
		else
		{			
			LastDevice=TRUE;
		}
		MemberIndex = MemberIndex + 1;
	}
	while ((LastDevice == FALSE) && (MyDeviceDetected == FALSE));
	if(MyDeviceDetected==true)
	{
		if(CheckDevice())
			return true;
	}
	return false;
}

CInteractionData CHIDDevice::DeviceInteraction(CInteractionData tx)
{
	return DeviceInteraction(tx,40);
}

CInteractionData CHIDDevice::DeviceInteraction(CInteractionData tx,int n)
{
	DWORD	BytesWritten = 0;
	INT		Index =0;
	BOOL	Result=FALSE;
	DWORD NumberOfBytesRead;
	CInteractionData rx;
// 	try
// 	{
		if (WriteHandle != INVALID_HANDLE_VALUE)
		{
			byte* out=tx.GetDataList();
			Result = WriteFile(
				WriteHandle,
				out,
				OutputReportByteLength,
				&BytesWritten,
				NULL);
			delete[] out;
		}

		if (Result==FALSE)
		{
			CloseHandles();
			MyDeviceDetected = FALSE;
			return rx;
			//MessageBox("WriteFile Error","WriteFile",MB_OK);
		}
// 	}
// 	catch (CException* e)
// 	{
// 		throw _T("USBWirteError!!"+e->GetErrorMessage());
// 	}
	byte InputReport[256];
	if (ReadHandle != INVALID_HANDLE_VALUE)
	{
		Result = ReadFile 
		(ReadHandle, 
		InputReport, 
		InputReportByteLength, 
		&NumberOfBytesRead,
		(LPOVERLAPPED) &HIDOverlapped); 
	}
	if(m_pProgress==NULL)
	{
		Result = WaitForSingleObject(hEventObject,30000);
		switch (Result)
		{
		case WAIT_OBJECT_0:
			{
				rx.SetData(InputReport);
			}
			break;
		case WAIT_TIMEOUT:
			{			
				Result = CancelIo(ReadHandle);
				CloseHandles();
				MyDeviceDetected = FALSE;
				break;
			}
		default:
			{			
				CloseHandles();
				MyDeviceDetected = FALSE;
				break;
			}
		}
	}
	else
	{
		bool bOK=false;
		while(true)
		{
			Result = WaitForSingleObject(hEventObject,500);
			switch (Result)
			{
			case WAIT_OBJECT_0:
				{
					rx.SetData(InputReport);
					bOK=true;
				}
				break;
			case WAIT_TIMEOUT:
				{			
					
				}
				break;
			default:
				{			
					CloseHandles();
					MyDeviceDetected = FALSE;
					break;
				}
			}
			if(bOK)
			{
				break;
			}				
			n--;
			m_pProgress->SetPos(n);
			m_pProgress->UpdateWindow();
			if(n==0)
			{				
				break;
			}
		}
		m_pProgress->SetPos(0);
		if(!bOK)
		{
			Result = CancelIo(ReadHandle);
			CloseHandles();
			MyDeviceDetected = FALSE;
		}
	}
	ResetEvent(hEventObject);
	return rx;
}

void CHIDDevice::CloseHandles()
{
	//Close open handles.
	if (DeviceHandle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(DeviceHandle);
		DeviceHandle=INVALID_HANDLE_VALUE;
	}

	if (ReadHandle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(ReadHandle);
		ReadHandle=INVALID_HANDLE_VALUE;
	}

	if (WriteHandle != INVALID_HANDLE_VALUE)
	{
		CloseHandle(WriteHandle);
		WriteHandle=INVALID_HANDLE_VALUE;
	}
}

HANDLE CHIDDevice::RegisterForUsbEvents(HANDLE hWnd)
{
	DEV_BROADCAST_DEVICEINTERFACE DevBroadcastDeviceInterface;  

	DevBroadcastDeviceInterface.dbcc_size = sizeof(DevBroadcastDeviceInterface);  
	DevBroadcastDeviceInterface.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE; 
	GUID gHid;
	HidD_GetHidGuid(&gHid);
	DevBroadcastDeviceInterface.dbcc_classguid = gHid;  
	return RegisterDeviceNotification(hWnd, &DevBroadcastDeviceInterface, DEVICE_NOTIFY_WINDOW_HANDLE);
}

BOOL CHIDDevice::UnregisterForUsbEvents(HANDLE hHandle)
{
	return UnregisterDeviceNotification(hHandle);
}

void CHIDDevice::Close()
{
	MyDeviceDetected=false;
	CloseHandles();
}
const byte B[4]={0x2E,0x74,0x5C,0x3A};
void CHIDDevice::DECRYPT()
{
	int CNT0 = 0;
	byte j = 5;
	byte i;
	byte MASK;
	byte tmp_K;
	tmp_K = 0;
	while (CNT0 < 528) //0x210
	{
		if ((CNT0 & 0x0007) == 0)
		{
			if (j == 7)
			{
				j = 0;
			}
			else
			{
				j++;
			}
			tmp_K = KEY[j];
		}

		if ((HOP[1] & 0x08) == 0x08)
		{
			MASK = 0x10;
		}
		else
		{
			MASK = 0x01;
		}
		if ((HOP[2] & 0x01) == 0x01)
		{
			MASK = (byte)(MASK << 2);
		}
		if ((HOP[3] & 0x01) == 0x01)
		{
			MASK = (byte)(MASK << 1);
		}

		if ((HOP[0] & 0x02) == 0x02)
		{
			i = 0x01;
		}
		else
		{
			i = 0x00;
		}

		if ((HOP[0] & 0x40) == 0x40)
		{
			i = (byte)(i + 0x02);
		}

		if ((MASK & B[i]) == 0)
		{
			MASK = 0x00;
		}
		else
		{
			MASK = 0x80;
		}
		MASK = (byte)(MASK ^ HOP[2] ^ HOP[0] ^ tmp_K);

		HOP[0] = (byte)(HOP[0] << 1);
		if ((HOP[1] & 0x80) == 0x80)
		{
			HOP[0] = (byte)(HOP[0] | 0x01);
		}
		else
		{
			HOP[0] = (byte)(HOP[0] & 0xFE);
		}

		HOP[1] = (byte)(HOP[1] << 1);
		if ((HOP[2] & 0x80) == 0x80)
		{
			HOP[1] = (byte)(HOP[1] | 0x01);
		}
		else
		{
			HOP[1] = (byte)(HOP[1] & 0xFE);
		}

		HOP[2] = (byte)(HOP[2] << 1);
		if ((HOP[3] & 0x80) == 0x80)
		{
			HOP[2] = (byte)(HOP[2] | 0x01);
		}
		else
		{
			HOP[2] = (byte)(HOP[2] & 0xFE);
		}

		HOP[3] = (byte)(HOP[3] << 1);
		if ((MASK & 0x80) == 0x80)
		{
			HOP[3] = (byte)(HOP[3] | 0x01);
		}
		else
		{
			HOP[3] = (byte)(HOP[3] & 0xFE);
		}

		tmp_K = (byte)(tmp_K << 1);
		CNT0++;
	}
}

void CHIDDevice::ENCODE()
{
	int CNT0 = 0;
	byte j = 0;
	byte i;
	byte MASK;
	byte tmp_K;
	tmp_K = 0;
	while (CNT0 < 528) //0x210
	{
		if ((CNT0 & 0x0007) == 0)
		{
			if (j == 0)
			{
				j = 7;
			}
			else
			{
				j--;
			}
			tmp_K = KEY[j];
		}

		if ((HOP[1] & 0x10) == 0x10)
		{
			MASK = 0x10;
		}
		else
		{
			MASK = 0x01;
		}
		if ((HOP[2] & 0x02) == 0x02)
		{
			MASK = (byte)(MASK << 2);
		}
		if ((HOP[3] & 0x02) == 0x02)
		{
			MASK = (byte)(MASK << 1);
		}

		if ((HOP[0] & 0x04) == 0x04)
		{
			i = 0x01;
		}
		else
		{
			i = 0x00;
		}

		if ((HOP[0] & 0x80) == 0x80)
		{
			i = (byte)(i + 0x02);
		}

		if ((MASK & B[i]) == 0)
		{
			MASK = 0x00;
		}
		else
		{
			MASK = 0x01;
		}

		MASK = (byte)(MASK ^ HOP[1] ^ HOP[3] ^ tmp_K);

		HOP[3] = (byte)(HOP[3] >> 1);
		if ((HOP[2] & 0x01) == 0x01)
		{
			HOP[3] = (byte)(HOP[3] | 0x80);
		}
		else
		{
			HOP[3] = (byte)(HOP[3] & 0x7F);
		}

		HOP[2] = (byte)(HOP[2] >> 1);
		if ((HOP[1] & 0x01) == 0x01)
		{
			HOP[2] = (byte)(HOP[2] | 0x80);
		}
		else
		{
			HOP[2] = (byte)(HOP[2] & 0x7F);
		}

		HOP[1] = (byte)(HOP[1] >> 1);
		if ((HOP[0] & 0x01) == 0x01)
		{
			HOP[1] = (byte)(HOP[1] | 0x80);
		}
		else
		{
			HOP[1] = (byte)(HOP[1] & 0x7F);
		}

		HOP[0] = (byte)(HOP[0] >> 1);
		if ((MASK & 0x01) == 0x01)
		{
			HOP[0] = (byte)(HOP[0] | 0x80);
		}
		else
		{
			HOP[0] = (byte)(HOP[0] & 0x7F);
		}

		tmp_K = (byte)(tmp_K >> 1);
		CNT0++;
	}
}

bool CHIDDevice::CheckDevice()
{
	CInteractionData tx;

	tx.buff[0] = 0x03;
	tx.buff[1] = 0x55;	//主机-->设备
	CInteractionData rx = DeviceInteraction(tx);
	if (!rx.bOK || rx.CheckDataList() == false)
		return false;
	HexID[0] = rx.buff[0x10];
	HexID[1] = rx.buff[0x11];
	HexID[2] = rx.buff[0x12];
	HexID[3] = rx.buff[0x13];
	//             if (HexID[0] != 0x04 || HexID[1] != 0x45 || HexID[2] != 0x61 || HexID[3] != 0x67)
	//                 return false;
	tx.Init();
	rx = DeviceInteraction(tx);
	if (!rx.bOK || rx.CheckDataList() == false)
		return false;
	HexVer[0] = rx.buff[0x10];
	HexVer[1] = rx.buff[0x11];
	return true;
}

CInteractionData CHIDDevice::Check_mima()
{
	CInteractionData tx;

	tx.buff[0] = 0x03;
	tx.buff[1] = 0x55;	//主机-->设备
	CInteractionData rx = DeviceInteraction(tx);
	if (!rx.bOK)
	{
		rx.hidResult= HIDResult_USBError;
		return rx;
	}
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
		return rx;
	}
	KEY[0] = 0x02;
	KEY[1] = 0x58;
	KEY[2] = 0xBE;
	KEY[3] = 0x24;
	//             KEY[4] = 0x8A;
	//             KEY[5] = 0x95;
	//             KEY[6] = 0x60;
	//             KEY[7] = 0x3D;

	KEY[4] = (byte)(HexID[0] - 0x77);
	KEY[5] = (byte)(HexID[1] - 0x55);
	KEY[6] = (byte)(HexID[2] - 0x33);
	KEY[7] = (byte)(HexID[3] - 0x11);

	HOP[0] = rx.buff[0x14];
	HOP[1] = rx.buff[0x15];
	HOP[2] = rx.buff[0x16];
	HOP[3] = rx.buff[0x17];

	DECRYPT();
	if ((HOP[0x02] == rx.buff[0x18]) && (HOP[3] == rx.buff[0x19]))
		rx.mimaok=true;
	else
	{
		rx.mimaok=false;
		rx.hidResult=HIDResult_MimaErr;
	}
	return rx;
}

CInteractionData CHIDDevice::ReadKeyData(byte type)
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = type;
	tx.buff[1] = 0x55;	//主机-->设备 
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_ReadError;
	}
	return rx;
}

CInteractionData CHIDDevice::ReadPSW1(byte type)
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = type;
	tx.buff[1] = 0x55;	//主机-->设备 
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x03)
	{
		rx.hidResult= HIDResult_GetPSWError3;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_GetPSWError1;
	}
	return rx;
}

CInteractionData CHIDDevice::ReadPSW2()
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x01;
	tx.buff[1] = 0xaa;	//主机<--设备
	tx.buff[4] = 0x20;
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] != 0x01)
	{
		rx.hidResult= HIDResult_GetPSWError2;		
	}
	else
	{
		rx.hidResult= HIDResult_OK;
	}
	return rx;
}

CInteractionData CHIDDevice::WriteKeyData1(int step)
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x01;
	tx.buff[1] = 0x55;	//主机-->设备
	int len=(step+1)*0x30;
	if(len<0xa0)
	{
		tx.buff[4] = 0x30;//本次传送数据的长度；
	}
	else
	{
		tx.buff[4]=0xa0-step*0x30;
	}
	tx.buff[5] += step*0x30;
	for (int i = 0; i < tx.buff[4]; i++)
	{
		tx.buff[i + 0x10] = KeyDataBuf[tx.buff[5]+i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_ReadError;
	}
	return rx;
}

CInteractionData CHIDDevice::WriteKeyData2(byte type)
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = type;
	tx.buff[1] = 0x55;	//主机-->设备 
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_ReadError;
	}
	return rx;
}



const byte CHIDDevice::DTnec[12]={0x00,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x23,0x01,0x26};

const byte CHIDDevice::DTmot[12]={0x00,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x23,0x01,0x26};

CInteractionData CHIDDevice::EZSReadDataStep( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x0D;
	tx.buff[1] = 0x55;	//主机-->设备
	tx.buff[0x0A] = 0x02;//cnt
	tx.buff[0x0B] = 0x6F;            

	tx.buff[0x0C] = (byte)step; 
	byte tmp_cmd = tx.buff[0x0C];

	rx = DeviceInteraction(tx);
	if (!rx.bOK)
	{
		rx.hidResult= HIDResult_USBError;
	}
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[0x01] == 0x01)
	{
		rx.hidResult= HIDResult_ReadEZSError1;
	}
	else if (rx.buff[0x01] == 0x02)
	{
		rx.hidResult= HIDResult_ReadEZSError2;
	}
	else if (rx.buff[0x0B] != 0x70)
	{
		rx.hidResult= HIDResult_ReadEZSError3;
	}
	//             else if (rx.buff[0x0C] != tmp_cmd)
	//             {
	//                 return HIDResult.ReadEZSError4;
	//             }
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_ReadEZSError5;
	}
	return rx;
}
const byte CHIDDevice::CANInfo_AT[0x09][0x10]={
	{0x00,0x0B,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
	{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x1A,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x03},
	{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
	{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};
CInteractionData CHIDDevice::CANInfoDataStep( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4]=0x20;
	for(int i=0;i<0x10;i++)
	{
		tx.buff[i+0x10]=CANInfo_AT[step][i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

const byte CHIDDevice::CANEeprom_Cmd00[0x24]=
{
	0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,
	0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,
	0x20,0x21,0x23,0x26
};

const byte CHIDDevice::CANEeprom_a[0x02][0x10]=
{
	{0x00,0x0B,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
};

const byte CHIDDevice::CANEeprom_b[0x03][0x10]=
{
	{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
};

const byte CHIDDevice::CANEeprom_c[0x04][0x10]=
{
	{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x21,0x05,0x6F,0x26,0xFF,0xFF,0xFF,0x00,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
	{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};

CInteractionData CHIDDevice::CANEeprom1Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4]=0x20;
	for(int i=0;i<0x10;i++)
	{
		tx.buff[i+0x10]=CANEeprom_a[step][i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

CInteractionData CHIDDevice::CANEeprom2Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4] = 0x20;
	for (int i = 0; i < 0x10; i++)
	{
		tx.buff[i + 0x10] = CANEeprom_b[step%3][i];
	}	
	if (0x01 == (step % 3))
	{
		tx.buff[0x0A + 0x10] = CANEeprom_Cmd00[step / 3];
	}            
	rx = DeviceInteraction(tx);
	rx.rxCount = CANEeprom_b[step % 3][0x0f];
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

CInteractionData CHIDDevice::CANEeprom3Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4] = 0x20;
	for (int i = 0; i < 0x10; i++)
	{
		tx.buff[i + 0x10] = CANEeprom_c[step][i];
	}	
	rx = DeviceInteraction(tx);
	rx.rxCount = CANEeprom_c[step][0x0f];
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

const byte CHIDDevice::CANwr_a[0x06][0x10]=
{
	{0x00,0x0B,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
	{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x10,0x0B,0x31,0x22,0x0A,0x7C,0xFE,0xD6,0x00,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x21,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x00,0x00,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
};

const byte CHIDDevice::CANwr_b[0x03][0x10]=
{
	{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x11,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x00,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
};

const byte CHIDDevice::CANwr_bChk[0x05][0x10]=
{
	{0x01,0xAA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x08,0x10,0x0C,0x71,0x22,0x73,0x0B,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x07,0x21,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x07,0x03,0x7F,0x31,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	{0x08,0x55,0x10,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//c check
};

const byte CHIDDevice::CANwr_c[0x03][0x10]=
{
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
	{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x1E,0x01},
	{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x1E,0x01},
};

const byte CHIDDevice::CANwr_d[0x04][0x10]=
{
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
	{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
	{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x1E,0x01},
	{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};

const byte CHIDDevice::CANwr_e[0x04][0x10]=
{
	{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
	{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
	{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
	{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
};

CInteractionData CHIDDevice::CANWrite1Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4] = 0x20;
	for (int i = 0; i < 0x10; i++)
	{
		tx.buff[i + 0x10] = CANwr_a[step][i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

CInteractionData CHIDDevice::CANWrite2Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4] = 0x20;
	for (int i = 0; i < 0x10; i++)
	{
		tx.buff[i + 0x10] = CANwr_b[step][i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else if(rx.buff[1] == 0x03)
	{
		rx.hidResult=HIDResult_CANWriteWait;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

CInteractionData CHIDDevice::CANWrite3Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4] = 0x20;
	for (int i = 0; i < 0x10; i++)
	{
		tx.buff[i + 0x10] = CANwr_c[step][i];
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else if(rx.buff[1] == 0x03)
	{
		rx.hidResult=HIDResult_CANWriteWait;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

CInteractionData CHIDDevice::CANWrite4Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4] = 0x20;
	for (int i = 0; i < 0x10; i++)
	{
		tx.buff[i + 0x10] = CANwr_d[step%2][i];
	}
	if (step % 2 == 1)
	{
		for (int i = 0; i < 0x08; i++)
		{
			tx.buff[i + 0x13] = DTwr[0x08 * DTwrIndex + i];//DATAwr[k][i];
		}
		tx.buff[0x12] = (byte)DTwrIndex;
		DTwrIndex++;
	}
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else if (rx.buff[1] == 0x03)
	{
		rx.hidResult= HIDResult_CANWriteWait;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

CInteractionData CHIDDevice::CANWrite5Step( int step )
{
	CInteractionData tx;
	CInteractionData rx;
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4] = 0x20;
	for (int i = 0; i < 0x10; i++)
	{
		tx.buff[i + 0x10] = CANwr_e[step][i];
	}           
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
		rx.hidResult= HIDResult_USBError;
	else if (rx.CheckDataList() == false)
	{
		rx.hidResult= HIDResult_RxError;
	}
	else if (rx.buff[1] == 0x00)
	{
		rx.hidResult= HIDResult_OK;
	}
	else if (rx.buff[1] == 0x03)
	{
		rx.hidResult= HIDResult_CANWriteWait;
	}
	else
	{
		rx.hidResult= HIDResult_CANErr;
	}
	return rx;
}

void CHIDDevice::SetEISWriteBuf(byte* pbuf)
{
	//key0
	for(int i=0;i<8;i++)
		DTwr[i]=pbuf[0x01ac+i];
	//key1
	for(int i=0;i<8;i++)
		DTwr[0x08+i]=pbuf[0x01be+i];
	//key2
	for(int i=0;i<8;i++)
		DTwr[0x10+i]=pbuf[0x01d0+i];
	//key3
	for(int i=0;i<8;i++)
		DTwr[0x18+i]=pbuf[0x01e2+i];
	//key4
	for(int i=0;i<8;i++)
		DTwr[0x20+i]=pbuf[0x01f4+i];
	//key5
	for(int i=0;i<8;i++)
		DTwr[0x28+i]=pbuf[0x0206+i];
	//key6
	for(int i=0;i<8;i++)
		DTwr[0x30+i]=pbuf[0x0218+i];
	//key7
	for(int i=0;i<8;i++)
		DTwr[0x38+i]=pbuf[0x022a+i];
	//Dealer
	for(int i=0;i<8;i++)
		DTwr[0x40+i]=pbuf[0x019a+i];
	//PSW
	for(int i=0;i<8;i++)
		DTwr[0x48+i]=pbuf[0x008e+i];
	//SSID
	for(int i=0;i<4;i++)
		DTwr[0x58+i]=pbuf[0x0be+i];
	//00-07
	for(int i=0;i<8;i++)
		DTwr[0x50+i]=i;
	DTwr[0x58 + 0x04] = 0x00;
	//	pBuf2[0x58+0x04]=DTwr[0x58+0x04];
	DTwr[0x58 + 0x05] = 0x00;
	//	pBuf2[0x58+0x05]=DTwr[0x58+0x05];
	DTwr[0x58 + 0x06] = 0x00;
	//	pBuf2[0x58+0x06]=DTwr[0x58+0x06];
	DTwr[0x58 + 0x07] = 0x1c;
	//	pBuf2[0x58+0x07]=DTwr[0x58+0x07];  
}

CString CHIDDevice::GetCANInfoStr( byte* pBuf )
{
	CString str,strx,strxx;
	CString strTemp,strTemp1,strInfo;
	char ljh[11];
	for (int i = 0; i < 10; i++)
		ljh[i] = pBuf[0x4 + i];
	ljh[10] = 0;
	str=ljh;
	strInfo=_T("");
	strTemp.LoadString(IDS_MBLJH);
	strTemp=_T("EZS ")+strTemp;
	strInfo+=strTemp+_T(" : ")+str;
	strInfo+="\r\n";


	strTemp.LoadString(IDS_HardStatus);
	str=CCommFunc::byteToHexStr(pBuf, 0, 2, _T(" "));
	strInfo+=strTemp+_T(" : ")+str;
	strInfo+="\r\n";


	strTemp.LoadString(IDS_SoftStatus);
	str=CCommFunc::byteToHexStr(pBuf, 2, 2, _T(" "));
	strInfo+=strTemp+_T(" : ")+str;
	strInfo+="\r\n";

	strInfo+=_T("-----------------------------");
	strInfo+="\r\n";

	strTemp.LoadString(IDS_OperationalStatus);
	strInfo+=strTemp+_T(":");
	strInfo+="\r\n";

	CString str1, str2, str3, str4;
	strTemp.LoadString(IDS_Initialised);
	if (CCommFunc::GetBit(pBuf[0x13], 0))
	{		
		strTemp1.LoadString(IDS_Yes);
		str1 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(IDS_No);
		str1 = strTemp+_T(":")+strTemp1;
	}

	strTemp.LoadString(IDS_TPRemoved);
	if (CCommFunc::GetBit(pBuf[0x13], 1))
	{		
		strTemp1.LoadString(IDS_Yes);
		str2 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(IDS_No);
		str2 = strTemp+_T(":")+strTemp1;
	}

	strTemp.LoadString(IDS_Personalised);
	if (CCommFunc::GetBit(pBuf[0x13], 2))
	{		
		strTemp1.LoadString(IDS_Yes);
		str3 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(IDS_No);
		str3 = strTemp+_T(":")+strTemp1;
	}

	strTemp.LoadString(IDS_Activated);
	if (CCommFunc::GetBit(pBuf[0x13], 3))
	{		
		strTemp1.LoadString(IDS_Yes);
		str4 = strTemp+_T(":")+strTemp1;
	}
	else
	{
		strTemp1.LoadString(IDS_No);
		str4 = strTemp+_T(":")+strTemp1;
	}	
	strInfo+=str1;
	strInfo+="\r\n";
	strInfo+=str2;
	strInfo+="\r\n";
	strInfo+=str3;
	strInfo+="\r\n";
	strInfo+=str4;
	strInfo+="\r\n";

	strInfo+=_T("-----------------------------");
	strInfo+="\r\n";

	strTemp.LoadString(IDS_StateOfKeys);
	strInfo+=strTemp+_T(":");
	strInfo+="\r\n";

	for(int i=7;i>=0;i--)
	{
		strTemp.LoadString(IDS_Key);
		if (CCommFunc::GetBit(pBuf[0x12], i))
		{		
			strx.LoadString(IDS_Locked);
			strxx.Format(_T("%s %d : %s"),strTemp,7-i,strx);			
		}
		else
		{
			strx.LoadString(IDS_UnLock);
			strxx.Format(_T("%s %d : %s"),strTemp,7-i,strx);	
		}
		strInfo+=strxx;
		strInfo+="\r\n";
	}
	strInfo+=_T("=============================");
	return strInfo;
}
byte* CHIDDevice::CANReadInfoData( int mode,CProgressCtrl* pProgress,CInteractionData* pResult)
{
	//第1款
	const byte info_a[0x0B][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x1A,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x03},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款
	const byte info_b[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte info_c[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款
	const byte info_d[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x1A,0x87,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x03},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte info_e[0x0D][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte info_g[0x0D][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x01},//81
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte info_h[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x50,0xFF,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x51,0xFF,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0x11,0xFF,0xFF,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//转存规则
	const byte info_T[0x09][0x16]={
		{0x0A,0x0B,0x0C,0x0D,0x0F,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x19,0x1A,0x26,0x27,0x29,0x2A,0x2B,0x2C,0x2D,0x2E},
		{0x04,0x05,0x0C,0x0D,0x15,0x16,0x17,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x39},
		{0x04,0x05,0x0C,0x0D,0x15,0x16,0x17,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x31},
		{0x0A,0x0B,0x0C,0x0D,0x0F,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x19,0x1A,0x2E,0x2F,0x31,0x32,0x33,0x34,0x35,0x36},
		{0x0C,0x0D,0x14,0x15,0x1D,0x1E,0x1F,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x39},
		{0x04,0x05,0x0C,0x0D,0x15,0x16,0x17,0x19,0x1A,0x1B,0x1C,0x1D,0x1E,0x1F,0x29,0x2A,0x2B,0x2C,0x2D,0x2E,0x2F,0x31},
		{0x0C,0x0D,0x14,0x15,0x1D,0x1E,0x1F,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x39},
		{0x0C,0x0D,0x1C,0x1D,0x2D,0x2E,0x2F,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x51},
		{0x0C,0x0D,0x1C,0x1D,0x2D,0x2E,0x2F,0x31,0x32,0x33,0x34,0x35,0x36,0x37,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,0x51},
	};
	byte rdINFO[0x09]={0x0B,0x0C,0x0C,0x0C,0x0D,0x0C,0x0D,0x0C,0x0C};
	int k=rdINFO[mode];
	int i,j;
	byte TMP[0x20][0x10];
	switch(mode)
	{
		//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_a[j][i];
			}
		}
		break;
		//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_b[j][i];
			}
		}
		break;
		//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_c[j][i];
			}
		}
		break;
		//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_d[j][i];
			}
		}
		break;
		//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_e[j][i];
			}
		}
		break;
		//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_g[j][i];
			}
		}
		break;
		//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=info_h[j][i];
			}
		}
		break;
		//------

		//------
	default:
		pResult->hidResult= HIDResult_RxError;
		//MessageBox("未实现!!","Error",MB_OK);
		return NULL;
	}
	// 	pProgress->SetRange(0,k);   //设置进度条的范围为0-1000	
	// 	pProgress->SetPos(0);
	// 	pProgress->UpdateWindow();
	int pBufIndex=0;
	int cntR=0;
	int m=0;
	CInteractionData tx;
	CInteractionData rx;
	byte Rx;
	byte tmpRX[0x80];
	int P;
	for (P=0;P<k;)
	{
		// 		pProgress->SetPos(i);
		// 		pProgress->UpdateWindow();
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];;
		}
		Rx=tx.buff[0x1F];
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			//rx.hidResult= HIDResult_OK;
			cntR=0;
			if(0x01==P)
			{
				P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
			}
			P++;
		}
		else
		{
			//rx.hidResult= HIDResult_CANErr;
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				P++;//意为数据包加1，就是到了83.3K的数据包指向。
			}
			else
			{//非01包数据时的情况
				if((Rx>0x00)&&(Rx<0x80))
				{
					//ShowLog(rx.GetHIDResult());//非握手包数据返回错误
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						//ShowLog(rx.GetHIDResult());//重复多次握手后仍错误
						pResult->hidResult=HIDResult_CANErr;
						return NULL;
					}
				}
			}
		}
		//------------------
		if((Rx>0x00)&&(Rx<0x80))
		{
			for(i=0;i<0x08*Rx;i++)
			{
				tmpRX[m+i]=rx.buff[i+0x10];
			}
			m+=(0x08*Rx);
		}
	}
	byte *outBuf;		//输出缓存

	outBuf=new byte[0x80+0x01];	//最大64M内存
	memset(outBuf,0xFF,0x80);
	outBuf[0x80]=0;

	for(int i=0;i<0x16;i++)//0x80
	{
		j=info_T[mode][i];
		outBuf[i]=tmpRX[j];
	}
	return outBuf;
}
byte* CHIDDevice::IRReadData( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar)
{
	// TODO: Add your control notification handler code here
	unsigned int i,j,k;
	char tmp_cmd;
//	char BufPassWord[0x18];
	char Data[0x10*0x30];

	unsigned char Hsel[0x04][0x08];
	unsigned char Hnxt[0x03][0x08];
	unsigned char Htmp[0x08];
	//char DispSSD[0x0C];

	unsigned int m;
	unsigned char n,x,y;
	bool fSEL=false;
	bool fSam=false;
	bool fChk=false;
	unsigned char Scnt;

	
	bool FLGsel=false;
	bool Fspec=false;
	const byte fix[0x08]={0xC2,0xE9,0x01,0xF0,0xED,0xBA,0x7C,0x5C};
	switch(mode)
	{
	//------
	case 0x00:
	case 0x01:
	case 0x03:
		FLGsel=false;
		Fspec=false;
		break;
	//------
	case 0x02:
	case 0x05:
	case 0x07:
		FLGsel=true;
		Fspec=false;
		break;
	//------
	case 0x04:
	case 0x06:
		FLGsel=false;
		Fspec=true;
		break;
		//------

	//------
	default:
		
		return NULL;
	}

	pProgress->SetRange(0,100);   //设置进度条的范围为0-1000	
	pProgress->SetPos(100);
	pProgress->UpdateWindow();
	CString strTemp;
	strTemp.LoadString(IDS_WaitInsertKey);
	pStatusBar->SetText(strTemp, 0, 0);
	//m_pProgress=pProgress;
	bool bNeedInster=true;
// 	pProgress->SetRange(0,0x30);   //设置进度条的范围为0-1000	
// 	pProgress->SetPos(0);
// 	pProgress->UpdateWindow();
	bool bFail=false;
	for(i=0;i<0x10*0x30;i++)//0x80
	{
		Data[i]=0x00;
	}
	bool fShake=false;
	bool fSave=false;
	unsigned char MaxER=0x00;
	CInteractionData tx;
	CInteractionData rx;
	for(j=0,n=0;j<0x30;)//j++
	{
		tx.Init();
		tx.buff[0] = 0x0d;
		tx.buff[1] = 0x55;	//主机-->设备 
		
		tx.buff[0x0A] = 0x02;//cnt
		tx.buff[0x0B] = 0x6F;            

		tx.buff[0x0C] = (byte)j; 

		tmp_cmd=tx.buff[0x0C];

		rx = DeviceInteraction(tx);
		fSave=false;
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00 && rx.buff[0x0b]==0x70)
		{
			if(bNeedInster)
			{
				bNeedInster=false;
				m_pProgress=NULL;
				pProgress->SetRange(0,0x30);   //设置进度条的范围为0-1000	
				pProgress->SetPos(++n);
				pProgress->UpdateWindow();
			}
			if(fShake==false)
			{
				strTemp.LoadString(IDS_StartReadData);
				pStatusBar->SetText(strTemp, 0, 0);
			}
			fSave=true;
			fShake=true;
			MaxER=0x00;
			//j++;
			pProgress->SetPos(++n);
			pProgress->UpdateWindow();//i加1，同时设置新的进度位置
		}		
		else  if((rx.buff[0x01]==0x02)||(rx.buff[0x01]==0x01))
		{
			if(false==fShake)
			{
				MaxER++;
				pProgress->SetPos(100-MaxER);
				pProgress->UpdateWindow();
				if(MaxER>100)
				{
					//DspRead="Read Error2";//长时间没有插入车载端，超时
					//SetDlgItemText(IDC_EDIT11, DspRead);
					pResult->hidResult=HIDResult_InsertKeyTimeOut;
					return NULL;
				}
			}
			else
			{
				MaxER++;
				if(MaxER>30)
				{
					//握手后连续30次，收到无效数据或没收到数据
// 					pResult->hidResult=HIDResult_ReadEZSError4;
// 					return NULL;
					fSave=true;
					for(k=0;k<8;k++)
					{
						rx.buff[0x10+k]=0x00;
					}
					//if(j<0x30)
					//{
					//	j++;
					//}
				}
			}
		}
		else  if(rx.buff[0x0B]!=0x70)
		{
			pResult->hidResult=HIDResult_ReadEZSError3;
			return NULL;
		}
		//else  if(BufInput[0x0C]!=tmp_cmd)//j
		//{
		//	DspRead="Read Error4";
		//	SetDlgItemText(IDC_EDIT11, DspRead);
		//	return;
		//}
		else
		{
			pResult->hidResult=HIDResult_ReadEZSError5;
			return NULL;
		}
		if(true==fSave)
		{
			for(k=0;k<8;k++)
			{
				Data[0x10*j+k]=rx.buff[0x10+k];
				//RDData[0x10*j+k]=rx.buff[0x10+k];
			}
			if(j<0x30)
			{
				j++;
			}
		}
	}
	//pResult->hidResult=HIDResult_OK;
	//------------------
	byte *outBuf;		//输出缓存

	outBuf=new byte[0x400+0x01];	//最大64M内存
	memset(outBuf,0xFF,0x400);
	outBuf[0x400]=0;

	//for(i=0;i<m;i++)//0x80
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//-----------------
	if(true==Fspec)
	{
		for(i=0;i<0x80;i++)
		{
			Data[0x270+i]=Data[0x20+i];
		}
		for(i=0;i<0x08;i++)
		{
			Data[0x260+i]=Data[0x100+i];
		}
	}
	//-----------------
	if(true==FLGsel)
	{
		for(k=0;k<0x08;k++)
		{
			m=0x0020;
			for(i=0;i<0x04;i++)
			{
				for(j=0;j<0x08;j++)
				{
					Hsel[i][j]=Data[m+k*0x10+j];
				}
				m=m+0x80;
			}
			//-----
			x=0x00;
			fSEL=false;
			while(false==fSEL)
			{
				CPassCalc cpCalc;
				for(i=0;i<8;i++)
				{
					cpCalc.HashIn[i]=Hsel[x][i];
				}
				cpCalc.sub_HashOnce();
				j=0x00;
				for(i=0;i<8;i++)
				{
					cpCalc.HashIn[i]=cpCalc.HashOut[i];
					Hnxt[j][i]=cpCalc.HashOut[i];
				}
				cpCalc.sub_HashOnce();
				j=0x01;
				for(i=0;i<8;i++)
				{
					cpCalc.HashIn[i]=cpCalc.HashOut[i];
					Hnxt[j][i]=cpCalc.HashOut[i];
				}
				cpCalc.sub_HashOnce();
				j=0x02;
				for(i=0;i<8;i++)
				{
					//HashIn[i]=HashOut[i];
					Hnxt[j][i]=cpCalc.HashOut[i];
				}
				//--
				Scnt=0x00;
				for(j=0;j<0x04;)//j++
				{
					if(j==x)
					{
						j++;
					}
					for(i=0;i<0x08;i++)
					{
						Htmp[i]=Hsel[j][i];
					}
					//--
					fChk=false;
					n=0x00;
					while(false==fChk)
					{
						fSam=true;
						for(i=0;i<0x08;i++)
						{
							if(Htmp[i]!=Hnxt[n][i])
							{
								fSam=false;
							}
						}
						if(true==fSam)
						{
							fChk=true;
							Scnt++;
						}
						else
						{
							n++;
							if(n==0x03)
							{
							fChk=true;
							}
						}
					}
					//--
					j++;
					if(j==x)
					{
					j++;
					}
					//--
				}
				if(0x03==Scnt)
				{
					fSEL=true;
					y=x;
				}
				else
				{
					x++;
					if(x==0x04)
					{
						fSEL=true;
						y=0x00;
					}
				}
			}
			//--
			for(i=0;i<0x08;i++)
			{
				Data[0x270+k*0x10+i]=Hsel[y][i];
			}
		}
		//-------
		fSam=true;
		for(i=0;i<0x08;i++)
		{
			if(Data[0x260+i]!=0x00)
			{
				fSam=false;
			}
		}
		if(true==fSam)
		{
			for(i=0;i<0x08;i++)
			{
				Data[0x260+i]=fix[i];
			}
		}
		//-------
	}
	//-----------------
	for(i=0;i<0x10*0x30;i++)//0x80
	{
		outBuf[i]=Data[i];
	}
	strTemp.LoadString(IDS_FinishReadData);
	pStatusBar->SetText(strTemp, 0, 0);
	//-----------------
	return outBuf;
}
byte* CHIDDevice::CANReadEEPROM( int mode,CProgressCtrl* pProgress,CInteractionData* pResult )
{
	int i,j;

	byte tmpRX[0x800];
	int m=0;
	//第1款--无错误动态字发生
	const byte CANee_A[0x0F][0x10]={
		//{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		//{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x21,0x05,0x6F,0x26,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANee_B[0x0B][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k		
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANee_C[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANee_D[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x21,0x05,0x6F,0x2F,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANee_E[0x0C][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANee_G[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANee_H[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;
	unsigned char k;

	byte rdEEDT[0x09][0x06]={
		{0x0F,0x08,0x0A,0x1A,0x00,0x00},//1--无错误
		{0x0B,0x05,0x07,0x1C,0x00,0x00},//2--无错误
		{0x0A,0x05,0x06,0x1C,0x01,0x05},//3--
		{0x0C,0x05,0x07,0x1A,0x00,0x00},//4--无错误
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//5--
		{0x0A,0x05,0x06,0x1C,0x01,0x05},//6--
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//7
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//8
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//9
	};
	byte rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	Z = rdEEDT[mode][0x03];
	JC = rdEEDT[mode][0x05];

	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		//MessageBox("未实现!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	} 
	//--//--LPcnt 可用作进度条变量
	//*/
	LPcnt=0x00;
	Ccnt=0x00;
	pProgress->SetRange(0,k);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	CInteractionData tx;
	CInteractionData rx;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];;
		}		
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = LPcnt;
		}
		rdCK[0x07] = LPcnt;//检查备用

		rx = DeviceInteraction(tx);

		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
			//
			if(0x01==P)
			{
				P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
			}
			//
			if((true==fCK)&&(JC==P))//需要检查而且行表一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x2F))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x2F)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				P++;//意为数据包加1，就是到了83.3K的数据包指向。
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						pResult->hidResult=HIDResult_CANErr;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//------------------
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//------------------
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
		
	}
	byte *outBuf;		//输出缓存

	outBuf=new byte[0x800+0x01];	//最大64M内存
	memset(outBuf,0xFF,0x800);//0X00
	outBuf[0x800]=0;

	const byte TS[0x09][0x0a]={
		{0x06,0x02,0x09,0x06,0x04,0x04,0x09,0x07,0x11,0x06},//1--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//2--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//3--
		{0x06,0x02,0x09,0x06,0x04,0x04,0x09,0x07,0x11,0x06},//4--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//5--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//6--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//7--
		{0x01,0x07,0x09,0x01,0x0D,0x03,0x11,0x07,0x19,0x07},//2--
		{0x01,0x07,0x09,0x01,0x0D,0x03,0x11,0x07,0x19,0x07},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];

	for(i=0;i<0x30;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//--
	i=0;
	AdL=TS[mode][4];
	AdC=TS[mode][5];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	AdL=TS[mode][6];
	AdC=TS[mode][7];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	AdL=TS[mode][8];
	AdC=TS[mode][9];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	return outBuf;
}
byte* CHIDDevice::CANReadEEPROM1( int mode,CProgressCtrl* pProgress,CInteractionData* pResult )
{
	int i,j;

	byte tmpRX[0x800];
	int m=0;
	//第1款--无错误动态字发生
	const byte CANee_A[0x0F][0x10]={
		//{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		//{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x21,0x05,0x6F,0x26,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x9C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANee_B[0x0B][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k		
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANee_C[0x0A][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANee_D[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x21,0x05,0x6F,0x2F,0xFF,0xFF,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANee_E[0x0C][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANee_G[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANee_H[0x0C][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x22,0xF1,0xA0,0x22,0x6F,0x2F,0xFF,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;
	unsigned char k;

	byte rdEEDT[0x09][0x06]={
		{0x0F,0x08,0x0A,0x1A,0x00,0x00},//1--无错误
		{0x0B,0x05,0x07,0x1C,0x00,0x00},//2--无错误
		{0x0A,0x05,0x06,0x1C,0x01,0x05},//3--
		{0x0C,0x05,0x07,0x1A,0x00,0x00},//4--无错误
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//5--
		{0x0A,0x05,0x06,0x1C,0x01,0x05},//6--
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//7
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//8
		{0x0C,0x05,0x07,0x1C,0x01,0x06},//9
	};
	byte rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	Z = rdEEDT[mode][0x03];
	JC = rdEEDT[mode][0x05];

	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANee_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		//MessageBox("未实现!!","Error",MB_OK);
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	} 
	//--//--LPcnt 可用作进度条变量
	//*/
	LPcnt=0x00;
	Ccnt=0x00;
	pProgress->SetRange(0,k);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	CInteractionData tx;
	CInteractionData rx;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];;
		}		
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = LPcnt;
		}
		rdCK[0x07] = LPcnt;//检查备用

		rx = DeviceInteraction(tx);

		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
			//
			if(0x01==P)
			{
				P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
			}
			//
			if((true==fCK)&&(JC==P))//需要检查而且行表一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x2F))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x2F)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				P++;//意为数据包加1，就是到了83.3K的数据包指向。
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
					pResult->hidResult=HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
						pResult->hidResult=HIDResult_CANErr;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//------------------
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//------------------
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
		
	}
	byte *outBuf;		//输出缓存

	outBuf=new byte[0x800+0x01];	//最大64M内存
	memset(outBuf,0xFF,0x800);//0X00
	outBuf[0x800]=0;

	const byte TS[0x09][0x0a]={
		{0x06,0x02,0x09,0x06,0x04,0x04,0x09,0x07,0x11,0x06},//1--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//2--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//3--
		{0x06,0x02,0x09,0x06,0x04,0x04,0x09,0x07,0x11,0x06},//4--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//5--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//6--
		{0x01,0x07,0x09,0x01,0x05,0x03,0x09,0x07,0x11,0x07},//7--
		{0x01,0x07,0x09,0x01,0x0D,0x03,0x11,0x07,0x19,0x07},//2--
		{0x01,0x07,0x09,0x01,0x0D,0x03,0x11,0x07,0x19,0x07},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];

	for(i=0;i<0x30;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//--
	i=0;
	AdL=TS[mode][4];
	AdC=TS[mode][5];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	AdL=TS[mode][6];
	AdC=TS[mode][7];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	AdL=TS[mode][8];
	AdC=TS[mode][9];
	for(j=0;j<AdC;j++,i++)
	{
		outBuf[0x30*0x10+i]=tmpRX[0x30*0x10+AdL+j];
	}
	return outBuf;
}
void CHIDDevice::CANWriteEZS( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,CEZSData* pEZSData)
{
	int i,j,k;
	bool Shk=false;
	int OVchk=0;
	int m=0;
	//char *pBuf;
	//DWORD dwFileLen;
	//
	//第1款
	const byte CANwr_A[0x16][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x10,0x0B,0x31,0x22,0x0A,0x7C,0xFE,0xD6,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x21,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x00,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x71},//0x71,替换为文件ID数据，然后高字节置零
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x00,0x01},//0A
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},//0B
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x12,0x00},//0C
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x1E,0x71},//
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x10,0x00},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款
	const byte CANwr_B[0x11][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k		
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0D,0x31,0x01,0x03,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//09-
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x03,0x22,0x0B,0xFF,0xFF,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x30,0x71},
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},	
	};
	//第3款,第6款
	const byte CANwr_C[0x0E][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0D,0x31,0x01,0x00,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x71},//08
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x00,0x01},
		//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		//--
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//
	//第4款
	const byte CANwr_D[0x10][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k	
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0B,0x31,0x22,0x0A,0x7C,0xFE,0xD6,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0x5C,0x68,0xFF,0x98,0x9C,0x98,0x9C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//08
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x03,0x31,0x22,0x0B,0x7C,0xFE,0xD6,0x5C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x30,0x71},//0B
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};

	//第5款
	const byte CANwr_E[0x11][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K
		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x10,0x0D,0x31,0x01,0x00,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x02},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//08
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x00,0x01},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x02,0x00},
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x28,0x71},//0C
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};

	//第7款//第8款//第9款
	const byte CANwr_G[0x11][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//0x07

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x10,0x0D,0x31,0x01,0x00,0x22,0x0A,0x7C,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x21,0xFE,0xD6,0x5C,0x68,0xFF,0x98,0x9C,0x00,0x02},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x12,0x70},//08
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x00,0x01},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},
		//--
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x05,0x31,0x01,0x00,0x22,0x0B,0x7C,0xFE,0x02,0x00},
		{0x03,0x1C,0xF0,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x1C,0x00,0x00,0x0A,0x28,0x71},//0C
		//--
		{0x04,0x1C,0x00,0x48,0x45,0xD8,0x26,0x81,0xB0,0x5D,0x63,0x00,0x00,0x00,0x1E,0x01},
		//--
		{0x05,0x1C,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1E,0x01},
		{0x03,0x1C,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x0A,0x20,0x01},
		//--
		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	byte CANwr_CK[0x03][0x10]={
		{0x07,0x03,0x7F,0x31,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x08,0x55,0x10,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//unused
		{0x07,0x03,0x7F,0x31,0x78,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//unused
	};
	unsigned char TMP[0x20][0x10];
	unsigned char LPstart,LPend,LPdt,LPcnt;
	unsigned char SHstart,SHend,SHck,SHcnt;
	unsigned char SUstart,SUend,SUcnt;
	unsigned char total;

	unsigned char wrEEDT[0x09][0x09]={
		{0x16,0x09,0x0B,0x0A,0x0C,0x0D,0x0E,0x0F,0x0F},//1----

		{0x11,0x09,0x0B,0x0A,0xFF,0xFF,0x0D,0x0D,0x0D},//2----

		{0x0E,0x08,0x09,0x08,0xFF,0xFF,0x0A,0x0A,0x0A},//3----

		{0x10,0x08,0x0A,0x09,0xFF,0xFF,0x0C,0x0C,0x0C},//4----

		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//5----

		{0x0E,0x08,0x09,0x08,0xFF,0xFF,0x0A,0x0A,0x0A},//6----

		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//7----

		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//8
		{0x11,0x08,0x0A,0x09,0x0B,0x0C,0x0D,0x0D,0x0D},//9
	};

	total = wrEEDT[mode][0x00];
	SHstart = wrEEDT[mode][0x01];//循环握手的开始行标
	SHend = wrEEDT[mode][0x02];  //循环握手的结尾行标
	SHck =  wrEEDT[mode][0x03];  //循环握手的核对行标
	SUstart = wrEEDT[mode][0x04];//再确认握手的开始行标
	SUend = wrEEDT[mode][0x05];  //再确认握手的结尾行标


	SHcnt = 0x00; //握手计数
	SUcnt=0x00; //在确认的计数
	bool fShake=false;
	bool fSure=false;

	LPstart = wrEEDT[mode][0x06];
	LPend = wrEEDT[mode][0x07];
	LPdt = wrEEDT[mode][0x08];
	LPcnt = 0x00;
	bool fDT=false;

	bool fRS=false;//握手数据比较标识
	bool fAdd=false;

	bool fDone=false;

	unsigned char Wake=0x00;//唤醒包的重复次数
	
	switch(mode)
	{
	case 0x00:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_A[j][i];
			}
		}
		break;
	case 0x01:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_B[j][i];
			}
		}
		break;
	case 0x02:
	case 0x05:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_C[j][i];
			}
		}
		break;
	case 0x03:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_E[j][i];
			}
		}
		break;
	case 0x06:
	case 0x07:
	case 0x08:
		for(j=0;j<total;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANwr_G[j][i];
			}
		}
		break;
	default:
		pResult->hidResult=HIDResult_CANErr;
		return;
	}
	//-----------------------------------------
	
	char DTwr[0x0C*0X08];
	for(i=0,j=0;i<0x08*0x08;i++)
	{
		DTwr[i]=pEZSData->AllFile[(0x270+(i/0x08)*0x10)+j];
		j++;
		j=j%0x08;
	}
	for(i=0;i<8;i++)
	{
		DTwr[0x40+i]=pEZSData->AllFile[0x10+i];
	}
	for(i=0;i<8;i++)
	{
		DTwr[0x48+i]=pEZSData->PSW[i];//此处判断文件是否已载入过，即可使用，如果未载入要提示打开BIN文件
	}
	for(i=0;i<8;i++)
	{
		DTwr[0x50+i]=pEZSData->AllFile[0x220+i];
	}
	for(i=0;i<4;i++)
	{
		DTwr[0x58+i]=pEZSData->AllFile[0x00+i];
	}
	DTwr[0x58+0x04]=0x00;
	DTwr[0x58+0x05]=0x00;
	DTwr[0x58+0x06]=0x00;
	DTwr[0x58+0x07]=0x1c;
	int P;
	unsigned char Rx;

	CInteractionData tx;
	CInteractionData rx;
	pProgress->SetRange(0,total);   //设置进度条的范围为0-1000	
	pProgress->SetPos(0);
	pProgress->UpdateWindow();
	//*///--P 可用作进度条变量,以下有地方需要留意，请下翻
	k=0;
	for(P=0;P<total;)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x70==(Rx&0xF0))
		{
			Rx=Rx&0x0F;
			tx.buff[0x1F]=Rx;
			tx.buff[0x13]=DTwr[0x58];
			tx.buff[0x14]=DTwr[0x59];
			tx.buff[0x15]=DTwr[0x5A];
			tx.buff[0x16]=DTwr[0x5B];
		}
		if(P==LPdt)
		{
			for(i=0;i<0x08;i++)
			{
				tx.buff[i+0x13]=DTwr[0x08*k+i];//DATAwr[k][i];
			}
			tx.buff[0x12]=k;
			k++;
		}
		rx = DeviceInteraction(tx);
		fAdd=true;//默认是要递增取数位置的
		fDone=false;//执行过标识true代表已经执行过，不再进入执行
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
			if(0x01==P)
				{
					P+=0x02;//第一次波特率尝试时成功，直接跳过第二种，到正常数据发射；
					fAdd=false;//无需递增
					fDone=true;
				}
				//---<
				//--public part
				if((P==LPend)&&(false==fDT)&&(false==fDone))
				{
					fDone=true;
					LPcnt++;
					if(LPcnt<0x0C)
					{
						P=LPstart;
						fAdd=false;//无需递增
					}
					else
					{
						fDT=true;
					}
				}
				CString strTemp;
				strTemp.LoadString(IDS_CANWritting);
				pStatusBar->SetText(strTemp,0,0);
				//--
				//--第1款车载端
				if(0x00==mode)
				{
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
// 							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;
					}
					//
					if((SHck==P)&&(false==fDone))//检查
					{
						fRS=true;
						for(i=0;i<CANwr_CK[0][0];i++)
						{
							if(CANwr_CK[0][i+0x01]!=rx.buff[i+0x10])
							{
								fRS=false;
							}
						}
						if(true==fRS)
						{
							P=SUstart;
							fShake=true;
							fAdd=false;//无需递增
						}
						fDone=true;
					}
				}
				//--第2,4款车载端
				if((0x01==mode)||(0x03==mode))
				{
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
// 							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;
					}
					//
					if((SHck==P)&&(false==fDone))//检查
					{
						//--提示插入读设备
// 						DspRead="waiting insert device KEY";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						fDone=true;
					}
				}
				//--第3,6款车载端
				if((0x02==mode)||(0x05==mode))
				{
					if((SHck==P)&&(false==fDone))//检查
					{
						P+=2;//2
						fShake=true;
						fAdd=false;//无需递增
						fDone=true;
					}
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;
					}
					//
				}				
				//--第5,7,8,9款车载端
				if((0x04==mode)||(0x06==mode)||(0x07==mode)||(0x08==mode))
				{
					//--
					if((P==SHend)&&(false==fShake)&&(false==fDone))
					{
						SHcnt++;
						if(SHcnt>0x80)
						{
// 							DspRead="Error shakehands";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
							//MessageBox("Read Error","Read",MB_OK);
							pResult->hidResult=HIDResult_CANErr;
							return;
						}
						P=SHstart;
						fAdd=false;//无需递增
						fDone=true;
					}
					//
					if((SHck==P)&&(false==fDone))//需要检查而且行标一致
					{
						fRS=true;
						for(i=0;i<CANwr_CK[0][0];i++)
						{
							if(CANwr_CK[0][i+0x01]!=rx.buff[i+0x10])
							{
								fRS=false;
								//fAdd=true;//需递增
							}
						}
						if(true==fRS)
						{
							P+=3;//2
							fShake=true;
							fAdd=false;//无需递增
						}
						else
						{
							//--提示插入读设备
// 							DspRead="waiting insert device KEY";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
						}
						fDone=true;
					}
				}
		}
		else
		{
			if(0x01==P)
			{//第一次波特率尝试失败，不退出，继续测试
				//DspRead="83.3K波特率";软件默认以500K第一次测试；可以做个显示地方显示波特率，如果走到这就要显示变为83.3K
				//SetDlgItemText(IDC_EDIT11, DspRead);
				//P++;//意为数据包加1，就是到了83.3K的数据包指向。
				//fAdd=true;//需递增
				fDone=true;
			}
			if((0x03==P)&&(false==fDone))
			{
// 					DspRead="Error 波特率";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
				//MessageBox("Read Error","Read",MB_OK);
				//fDone=true;
				pResult->hidResult=HIDResult_CANErr;
				return;
			}
			//---第1款车载端
			if(0x00==mode)
			{
				//if(0x01==P)
				//{
					//fAdd=true;//需递增
				//}
				if((SHstart==P)&&(false==fDone))//((SHstart==P)&&(0x03==BufInput[1]))
				{
					//--提示插入读设备
// 						DspRead="waiting insert device KEY";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					//P++;
					CString strTemp;
					strTemp.LoadString(IDS_WaitInsertKey);
					pStatusBar->SetText(strTemp,0,0);
					fDone=true;
				}
				if((SUend==P)&&(false==fDone))
				{					
					fDone=true;
					SUcnt++;
					if(SUcnt>0x40)
					{
// 							DspRead="Error shake 2";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
						pResult->hidResult=HIDResult_CANErr;
						return;
					}
					else
					{
						P=SUstart;
						fAdd=false;//无需递增
					}
				}
			}
			//---第2,4款车载端
			if((0x01==mode)||(0x03==mode))
			{
				if((SHck==P)&&(false==fDone))//需要检查而且行标一致
				{
					fDone=true;
					//P=LPstart;
					P+=2;
					fShake=true;
					fAdd=false;//无需递增
				}
			}
			//--第3,6款车载端
			if((0x02==mode)||(0x05==mode))
			{
				if((SHck==P)&&(false==fDone))//需要检查而且行标一致
				{
					//--提示插入读设备
// 						DspRead="waiting insert device KEY";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					CString strTemp;
					strTemp.LoadString(IDS_WaitInsertKey);
					pStatusBar->SetText(strTemp,0,0);
					fDone=true;
				}
			}
			//--第5,7,8,9款车载端
			if((0x04==mode)||(0x06==mode)||(0x07==mode)||(0x08==mode))
			{
				if((SUend==P)&&(false==fDone))
				{
					fDone=true;
					SUcnt++;
					if(SUcnt>0x10)
					{
// 							DspRead="Error shake 5";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
						pResult->hidResult=HIDResult_CANErr;
						return;
					}
					else
					{
						P=SUstart;
						fAdd=false;//无需递增
					}
				}
			}
			//---------------------------
			//---public
			if(false==fDone)
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 						DspRead="Error wr N5";//后续写的时候跟据车载端选择和进度做为错误代码
// 						SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult=HIDResult_CANErr;
					return;
				}
				else
				{
					fAdd=false;//无需递增
					Wake++;
					if(Wake>0x20)
					{
// 							DspRead="Error 唤醒";
// 							SetDlgItemText(IDC_EDIT11, DspRead);
// 							//MessageBox("Read Error","Read",MB_OK);
						pResult->hidResult=HIDResult_CANErr;
						return;
					}
				}
			}				//---------------------------
			//}
			//---public			
		}
		if(true==fAdd)
		{
			P++;
		}
		pProgress->SetPos(P);
		pProgress->UpdateWindow();
		
	}

	pResult->hidResult=HIDResult_OK;
}

void CHIDDevice::RenewEZS( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,byte* pSSID,byte* pDPass,byte* pPass)
{
	int i;
	bool Shk=false;
	int OVchk=0;


	unsigned char Rnew[32];//

	byte EZS_a[0x02][0x10]={
		{0x03,0x50,0x00,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x1E,0x01},
		{0x03,0x53,0x77,0x09,0x4F,0x88,0x37,0x44,0x7C,0xF9,0x00,0x00,0x00,0x09,0x50,0x01},
	};

	byte RN_chk[0x10]=
		{0x0A,0x68,0x00,0x17,0x50,0x00,0xBB,0x85,0x52,0xDF,0x0A,0x00,0x00,0x00,0x00,0x00};
		
	//
	for(i=0;i<0x04;i++)
	{		
		EZS_a[0x00][i+0x03]=pSSID[i];
	}
	//
	//for(i=0;i<0x08;i++)
	//{
	//	Rnew[i]=DLER[i];
	//}
	
	for(i=0;i<0x08;i++)
	{
		//设置renew密码
		Rnew[i]=pDPass[i];
	}
	for(i=0;i<0x08;i++)
	{
		//设置密码
		Rnew[i+0x08]=pPass[i];
	}
	for(i=0;i<0x06;i++)
	{
		Rnew[i+0x10]=EZS_a[0x00][i+0x01];
	}

	//
	CInteractionData tx;
	CInteractionData rx;
	CString strTemp;
	strTemp.LoadString(IDS_WaitInsertKey);
	pStatusBar->SetText(strTemp,0,0);
	pProgress->SetRange(0,200);
	pProgress->SetPos(200);
	while(true!=Shk)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=EZS_a[0][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
			if(0x63!=rx.buff[0x11])
			{
				pResult->hidResult=HIDResult_RENEWError_a2;
				return;
			}
			Shk=true;
		}		
		else
		{
// 			DspRead="waiting insert device KEY";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		//
		if(OVchk>200)
		{
			pResult->hidResult=HIDResult_InsertKeyTimeOut;
			//MessageBox("Read Error","Read",MB_OK);
			return;
		}
		else
		{
			OVchk++;
			pProgress->SetPos(200-OVchk);
		}
		//------------------

	}
	//--
	for(i=0;i<0x09;i++)
	{
		Rnew[i+0x16]=rx.buff[i+0x11];
	}
	CPassCalc cpCalc;
	cpCalc.sub_CALrenew(Rnew);//此处应为调用加密狗计算
	for(i=0;i<8;i++)
	{
		EZS_a[0x01][0x02+i]=cpCalc.HashOut[i];
	}
// 	for(i=0;i<5;i++)
// 	{
// 		RN_chk[0x06+i]=cpCalc.HashOut[i];
// 	}
	for(i=0;i<5;i++)
	{
		RN_chk[0x06+i]=pDPass[i];
	}
	tx.Init();
	tx.buff[0] = 0x14;
	tx.buff[1] = 0x55;	//主机-->设备 
	tx.buff[4]=0x20;
		
	for(i=0;i<0x10;i++)
	{
		tx.buff[i+0x10]=EZS_a[1][i];
	}		
	rx = DeviceInteraction(tx);
	if (!rx.bOK)
	{
		pResult->hidResult= HIDResult_USBError;
		return;
	}
	else if (rx.CheckDataList() == false)
	{
		pResult->hidResult= HIDResult_RxError;
		return;
	}
	else if (rx.buff[1] == 0x00)
	{
		
	}
	else
	{
		pResult->hidResult= HIDResult_RenewError_b;
		return;
	}
	for(i=0;i<RN_chk[0x00];i++)
	{
		if(RN_chk[i+0x01]!=rx.buff[i+0x11])
		{
			pResult->hidResult= HIDResult_RenewError_b;
			return;
		}
	}
	pResult->hidResult=HIDResult_OK;
}

byte* CHIDDevice::SuanMiMa( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar,CEdit* m_StepLog)
{
	// TODO: Add your control notification handler code here
	int i;
	CString str;
	//------------
	const byte CAN_dtA[0x10]={0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//500k
	//const char CAN_dtB[0x10]={0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//83.3k
	bool fDut=false;//波特率重试标识；每次点下按钮，仅重试1次后。

	const byte RDcmd[0x0A]={0x00,0x01,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E};

	//第1款--无错误动态字发生
	const byte CANm_A[0x0A][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANm_B[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANm_C[0x06][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANm_D[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANm_E[0x07][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANm_G[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANm_H[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//---加步


	char tmpRX[0x800];
	int m;
	int j;
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;
	unsigned char cnt1=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char Td[0x10]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;//每次加1的送数
	unsigned char k;

	unsigned char rdEEDT[0x09][0x06]={
		{0x0A,0x06,0x08,0x1A,0x00,0x00},//1--无错误
		{0x07,0x03,0x05,0x1C,0x00,0x00},//2--无错误
		{0x06,0x03,0x04,0x1C,0x01,0x03},//3--
		{0x07,0x03,0x05,0x1A,0x00,0x00},//4--无错误
		{0x07,0x03,0x05,0x1C,0x01,0x04},//5--
		{0x06,0x03,0x04,0x1C,0x01,0x03},//6--
		{0x07,0x03,0x05,0x1C,0x01,0x04},//7
		{0x07,0x03,0x05,0x1C,0x01,0x04},//8
		{0x07,0x03,0x05,0x1C,0x01,0x04},//9
	};
	unsigned char rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	Z = rdEEDT[mode][0x03];//加入动态命令字的位置
	JC = rdEEDT[mode][0x05];//需要检查的行标

	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
//-------------------------
	const char TS[0x09][0x04]={
		{0x06,0x02,0x09,0x06},//1--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//3--
		{0x06,0x02,0x09,0x06},//4--
		{0x01,0x07,0x09,0x01},//5--
		{0x01,0x07,0x09,0x01},//6--
		{0x01,0x07,0x09,0x01},//7--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];
	//
	bool fSame=false;
	unsigned char readA[0x10],readB[0x10],readC[0x10],readD[0x10];
	unsigned char outBuf[0x800];
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		pResult->hidResult=HIDResult_CANErr;
		return NULL;
	}
	//--------------------
	str=_T("请把OBD线连接到车载端");
	if(MessageBox(str, _T("提示1"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	CInteractionData tx;
	CInteractionData rx;
// 	CString strTemp;
// 	strTemp.LoadString(IDS_WaitInsertKey);
//	pStatusBar->SetText(strTemp,0,0);
// 	pProgress->SetRange(0,200);
// 	pProgress->SetPos(200);
	//--------------------
	//以下程序如果可以做成模块调用会很方便，因不会在子程序中弹出窗口和操作显示基础操作等等，
	//所以写了4遍，完全一样，仅仅是调用后把数据取出后的操作不同，
	//此处即使做成模块也要用线程操作，P值的变化可以做成进度条或闪烁功能
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		//--
		if(0x00==rx.buff[1])
		{
			cntR=0x00;
// 			DspRead="Read EEDT OK";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
// 					DspRead="Read Error 83.3K";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 					DspRead="Read Error EEDT";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error EEDT 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		//MessageBox("车载端未激活!!","Error",MB_OK);
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}
	
	//------------------
	//第1遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readA[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readA[0x08+i]=outBuf[0xF0+i];
	}
	//------------------
	//----
	str=_T("将钥匙插入到EIS中，等待5秒");
	if(MessageBox(str, _T("提示2"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	//----
	str=_T("将钥匙从EIS中取出");
	if(MessageBox(str, _T("提示3"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	//----
	//--------------------
	//重复第2遍模块
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
// 			DspRead="Read EEDT OK";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
// 					DspRead="Read Error 83.3K";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 					DspRead="Read Error EEDT";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error EEDT 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
// 						//MessageBox("Read Error","Read",MB_OK);
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
// 		MessageBox("车载端未激活!!","Error",MB_OK);
 		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}		
	//------------------
	//第2遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readB[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readB[0x08+i]=outBuf[0xF0+i];
	}
	//
	fSame=true;
	for(i=0;i<4;i++)
	{
		if(readB[i]!=readA[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		//MessageBox("车载端读取异常!!","Error",MB_OK);
		return NULL;
	}
	//------------------
	//----	
	str=_T("再将钥匙插入到EIS中，等待5秒");
	if(MessageBox(str, _T("提示4"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	//----
	str=_T("再将钥匙从EIS中取出后插入到红外适配器中");
	if(MessageBox(str, _T("提示5"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	//----	
	//------------------
	//--------------------
	//重复第3遍模块
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		//
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
// 			DspRead="Read EEDT OK";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
// 			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
// 					DspRead="Read Error 83.3K";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 					DspRead="Read Error EEDT";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error EEDT 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		//MessageBox("车载端未激活!!","Error",MB_OK);
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}	
	//以上为重复第3遍的模块结尾；		

	
	//------------------
	//------------------
	//第3遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readC[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readC[0x08+i]=outBuf[0xF0+i];
	}
	//
	fSame=true;
	for(i=0;i<8;i++)
	{
		if(readB[i]!=readC[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		//MessageBox("车载端读取异常!!","Error",MB_OK);
		return NULL;
	}
	CPassCalc cpCalc;
	for(i=0;i<8;i++)
	{
		cpCalc.HashIn[i]=readC[0x08+i];
	}
	cpCalc.sub_HashOnce();	
	fSame=true;
	for(i=0;i<8;i++)
	{
		if(readB[0x08+i]!=cpCalc.HashOut[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		//MessageBox("钥匙插入EIS异常!!","Error",MB_OK);
		//return;
	}
	//------------------
	//----
	str=_T("再将钥匙从EIS中取出后插入到红外适配器中");
	if(MessageBox(str, _T("提示5"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	//----
	byte JiaB[0x06][0x10]={
		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x80,0x01},//0
		{0x06,0x26,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0xFF,0x09,0x20,0x01},//1

	//	{0x06,0x38,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x02,0x20,0x00},//2
		{0x06,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x01,0x80,0x01},//2

		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x16,0x00},//3

		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x00},//4

		{0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x40,0x01},//5
	};
	byte* IRdt=new byte[0x40*0x400];
	bool fFIN=false;
	unsigned int Ceer=0;
	unsigned int Ctry=0;
	unsigned char Cwait=0;
	//---

	for(i=0;i<0x40*0x400;i++)
	{
		IRdt[i]=0x00;
	}
	P=0x00;
	j=0;//此处也要用线程操作，j值的变化可以做成进度条或闪烁功能
	while(false==fFIN)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=JiaB[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			switch(P)
			{
				//------
				case 0x00:
					if(0x24==rx.buff[0x11])
					{
						for(i=0;i<0x08;i++)
						{
							IRdt[0x40*j+0x00+i]=rx.buff[0x11+i];
						}
						for(i=0;i<0x08;i++)
						{
							JiaB[0x01][0x02+i]=rx.buff[0x11+i];
						}
						for(i=0;i<0x09;i++)
						{
							IRdt[0x40*j+0x10+i]=JiaB[0x01][0x01+i];
						}
						P=0x01;
					}
					else
					{
						//MessageBox("钥匙读错误1","Read",MB_OK);
						//P=0x03;
						//return;
						Ceer++;
						if(Ceer>0x1800)//0x20
						{
							Ctry++;
							if(Ctry>0x04)
							{
								MessageBox(_T("重试多次后还是错误"));
								P=0x03;
							}
							else
							{
								P=0x05;//0x04
								Ceer=0x00;
							}
						}
					}
					break;
				//------
				case 0x01:
					if(0x27==rx.buff[0x11])
					{
						for(i=0;i<0x09;i++)
						{
							IRdt[0x40*j+0x20+i]=rx.buff[0x11+i];
						}
						P=0x02;
					}
					else
					{
						MessageBox(_T("钥匙读错误2"));
						return NULL;
					}
					Ceer=0x00;
					Ctry=0x00;
					j++;
					if(j>=0x400)
					{
						//fFIN=true;
						P=0x03;
					}
					break;
				//------
				case 0x02:
					if(0x24==rx.buff[0x11])
					{
						for(i=0;i<0x08;i++)
						{
							IRdt[0x40*j+0x00+i]=rx.buff[0x11+i];
						}
						for(i=0;i<0x08;i++)
						{
							JiaB[0x01][0x02+i]=rx.buff[0x11+i];
						}
						for(i=0;i<0x09;i++)
						{
							IRdt[0x40*j+0x10+i]=JiaB[0x01][0x01+i];
						}
						P=0x01;
					}
					else
					{
						Ceer++;
						if(Ceer>0x06)
						{
							//MessageBox(_T("钥匙读错误1"));
							P=0x00;
							//P=0x05;//0x00
						}
					}
					break;
				//------
				case 0x03:
					fFIN=true;
					break;
				//------
				case 0x04:
					P=0x00;
				//	fFIN=true;
					break;
				//------
				//------
				case 0x05:
					if(0x24==rx.buff[0x11])
					{
						P=0x03;
					}
					else
					{

					}
					break;
				//------				
				default:
				//MessageBox("未知错误1!","Error",MB_OK);
				return NULL;
			}
		}
		else
		{
			switch(P)
			{
				//------
				case 0x00:
				case 0x02:


					MessageBox(_T("没检测到钥匙!!"),_T("Read"),MB_OK);
					P=0x03;
					//return;
					break;
				//------
				case 0x01:
					MessageBox(_T("接收错误!!"),_T("Read"),MB_OK);
					P=0x03;
					//return;
					break;
				//------
				//------
				case 0x05:
					Cwait++;
					if(Cwait>0x03)
					{
						Cwait=0;
						P=0x00;
					}
					break;
				//------
				//------
				default:
					MessageBox(_T("未知错误2!"));
					return NULL;		
			}
		}
	}
	str=_T("钥匙已读完,将钥匙取出后插入到车载端等待30秒");
	if(MessageBox(str, _T("提示6"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	//----	
	//------------------
	str=_T("30秒到，请从EIS取出钥匙");
	if(MessageBox(str, _T("提示7"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		return NULL;
	}
	//----	
	//--------------------
	//重复第4遍模块
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		//
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
// 			DspRead="Read EEDT OK";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
// 					DspRead="Read Error 83.3K";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 					DspRead="Read Error EEDT";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error EEDT 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		//MessageBox("车载端未激活!!","Error",MB_OK);
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}
	//------------------
	//第4遍读车载端结束取数
	for(i=0;i<8;i++)
	{
		readD[i]=outBuf[i];
	}
	for(i=0;i<8;i++)
	{
		readD[0x08+i]=outBuf[0xF0+i];
	}
	//
	fSame=true;
	for(i=0;i<8;i++)
	{
		if(readD[i]!=readC[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		//MessageBox("车载端读取异常!!","Error",MB_OK);
		return NULL;
	}
	//
	//CPassCalc cpCalc;
 	for(i=0;i<8;i++)
 	{
 		//HashIn[i]=readD[0x08+i];
 		cpCalc.HashOut[i]=readD[0x08+i];
 	}
	//sub_HashOnce();
	//
	for(j=0;j<0x400;j++)
	{
		for(i=0;i<8;i++)
		{
			cpCalc.HashIn[i]=cpCalc.HashOut[i];
		}
		cpCalc.sub_HashOnce();
		for(i=0;i<8;i++)
		{
			IRdt[0x40*(0x3FF-j)+0x30+i]=cpCalc.HashOut[i];
		}
	}
	//
	for(i=0;i<8;i++)
	{
		cpCalc.HashIn[i]=cpCalc.HashOut[i];
	}
	cpCalc.sub_HashOnce();
	fSame=true;
	for(i=0;i<8;i++)
	{
		if(readC[0x08+i]!=cpCalc.HashOut[i])
		{
			fSame=false;
		}
	}
	if(false==fSame)
	{
		//MessageBox("采集数据异常!!","Error",MB_OK);
		//return;
	}
// 	//------------------
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(IRdt,0x40*0x400);
// 		file.Close();
// 	}
// 	//------------------
	return IRdt;
}

byte* CHIDDevice::ESLReadInfo(CProgressCtrl* pProgress,CInteractionData* pResult )
{
	// TODO: Add your control notification handler code here
	int i;
	byte* tmpRX=new byte[0x80];//tp[0x10];
	unsigned char Sum,TS;
	int m;
	int P;
	unsigned char Rx;
	unsigned char x,y,TA,TB;

	//第1款
	byte uart_INFO[0x03][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		//	{0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00},
		{0x02,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		{0x01,0x76,0x00,0x90,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x0B,0x00,0x0B},
	};
	const byte Cmd[0x03]={0x90,0x91,0xC7};
	bool fRD=false;

	//---
	for(i=0;i<0x80;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	m=0x00;
	P=0;
	//--m 可用作进度条变量
	fRD=false;
	CInteractionData tx;
	CInteractionData rx;
	while(false==fRD)
	{
		tx.Init();
		tx.buff[0] = 0x15;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;		
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=uart_INFO[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x02==P)
		{
			tx.buff[0x13]=Cmd[m];
			x=0x78;
			y=Cmd[m];
			Sum=0x00;
			for(i=0;i<0x0A;i++)
			{
				Sum+=tx.buff[0x11+i];
			}
			tx.buff[0x1B]=Sum;
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
// 			DspRead="Read OK 00";//每包发射都有返回，可以在非0时再显示
// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		else
		{
			pResult->hidResult= HIDResult_CANErr;
			return NULL;
// 			DspRead="接收超时";//
// 			SetDlgItemText(IDC_EDIT11, DspRead);
// 			MessageBox("接收超时","Read",MB_OK);
			
		}
		//------------------
		if(0x00!=Rx)
		{
			Sum=0x00;
			TS=rx.buff[0x1B];
			for(i=0;i<Rx-1;i++)
			{
				Sum+=rx.buff[i+0x11];
			}
			if(Sum!=TS)
			{
// 				DspRead="校验错误1";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误1","Read",MB_OK);
// 				return;
				pResult->hidResult= HIDResult_CANErr;
				return NULL;
			}
			TA=rx.buff[0x11];
			TB=rx.buff[0x12];
			if((x!=TA)||(y!=TB))
			{
// 				DspRead="校验错误2";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误2","Read",MB_OK);
// 				return;
				pResult->hidResult= HIDResult_CANErr;
				return NULL;
			}			
			//for(i=0;i<(Rx-0x01);)
			for(i=0;i<0x08;i++)
			{
				tmpRX[m*0x10+i]=rx.buff[i+0x13];
			}
			m++;
			if(m>=0x03)
			{
// 				DspRead="读INFO完成";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				fRD=true;
			}
		}
		//
		P++;
		if(P>=0x03)
		{
			P=0x01;
		}
		//------------------
	}
	return tmpRX;
}

byte* CHIDDevice::ESLReadData( CProgressCtrl* pProgress,CInteractionData* pResult )
{
	int i;
	byte* tmpRX=new byte[0x400];
	unsigned char Sum,TS;
	int m;
	int P;
	unsigned char Rx;
	unsigned char x,y,TA,TB;

	//第1款
	byte uart_INFO[0x03][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		//	{0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00},
		{0x02,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		{0x01,0x76,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x02,0x0B,0x00,0x0B},
	};
	const byte Cmd[0x34]={
		0x00,0x01,0x02,0x03,0x10,0x11,0x12,0x13,0x20,0x21,0x22,0x23,0x30,0x31,0x32,0x33,
		0x40,0x41,0x42,0x43,0x50,0x51,0x52,0x53,0x60,0x61,0x62,0x63,0x70,0x71,0x72,0x73,
		0x80,0x81,0x82,0x83,0x90,0x91,0x92,0x93,0x94,0xA0,0xB0,0xC0,0xC2,0xC3,0xC5,0xC7,
		0xC8,0xC9,0xCA,0xCB,};
		//
	bool fRD=false;

		
	for(i=0;i<0x400;i++)
	{
		tmpRX[i]=0x00;
	}
	//
	m=0x00;
	P=0;
	//--m 可用作进度条变量
	fRD=false;
	CInteractionData tx;
	CInteractionData rx;
	while(false==fRD)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x15;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=uart_INFO[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x02==P)
		{
			tx.buff[0x13]=Cmd[m];
			x=0x78;
			y=Cmd[m];
			Sum=0x00;
			for(i=0;i<0x0A;i++)
			{
				Sum+=tx.buff[0x11+i];
			}
			tx.buff[0x1B]=Sum;
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
// 			DspRead="Read OK 00";//每包发射都有返回，可以在非0时再显示
// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		else
		{
// 			DspRead="接收超时";//
// 			SetDlgItemText(IDC_EDIT11, DspRead);
// 			MessageBox("接收超时","Read",MB_OK);
			pResult->hidResult=HIDResult_CANErr;
			return NULL;
		}
		//------------------
		if(0x00!=Rx)
		{
			Sum=0x00;
			TS=rx.buff[0x1B];
			for(i=0;i<Rx-1;i++)
			{
				Sum+=rx.buff[i+0x11];
			}
			if(Sum!=TS)
			{
// 				DspRead="校验错误1";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误1","Read",MB_OK);
				pResult->hidResult=HIDResult_CANErr;
				return NULL;
			}
			TA=rx.buff[0x11];
			TB=rx.buff[0x12];
			if((x!=TA)||(y!=TB))
			{
// 				DspRead="校验错误2";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
// 				MessageBox("校验错误2","Read",MB_OK);
				pResult->hidResult=HIDResult_CANErr;
				return NULL;
			}			
			//for(i=0;i<(Rx-0x01);)
			for(i=0;i<0x08;i++)
			{
				tmpRX[m*0x08+i]=rx.buff[i+0x13];
			}
			m++;
			if(m>=0x34)
			{
// 				DspRead="读EE完成";//
// 				SetDlgItemText(IDC_EDIT11, DspRead);
				fRD=true;
			}
		}
		//
		P++;
		if(P>=0x03)
		{
			P=0x01;
		}
		//------------------
	}
	return tmpRX;
}

void CHIDDevice::ESLWrite(CProgressCtrl* pProgress, CInteractionData* pResult,byte* pBuf)
{	
	
}

void CHIDDevice::ESLRenew(byte* pPSW, CInteractionData* pResult )
{
	int i;

	//	unsigned char tmpRX[0x80];
	unsigned char Sum,TS;
	int P;
	unsigned char Rx;

	//第1款
	byte uart_RNEW[0x03][0x10]={
		{0x00,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		//	{0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x00},
		{0x02,0x84,0x80,0x00,0x00,0x68,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},

		{0x01,0x52,0x00,0xBB,0x00,0x00,0x00,0x00,0x00,0x00,0xD6,0x00,0x10,0x0B,0x00,0x0B},
	};
	//	const char Cmd[0x03]={0x90,0x91,0xC7};
	const byte TA[0x0A]={0x77,0x03,0x79,0x52,0x00,0x00,0x00,0x00,0x00,0x00};
	const byte TB[0x0A]={0x77,0x03,0x79,0x52,0xFF,0x00,0x00,0x00,0x00,0x00};
	unsigned char tp[0x0A];
	bool fSam=false;
	bool fRN=false;	

	//--载入打开的文件进行数据传送，后续开发要更改为自动填入服务器算得的结果，也是8字节
	for(i=0;i<0x08;i++)
	{
		uart_RNEW[0x02][i+0x03]=pPSW[i];
	}
	//--
	//
	P=0;
	//--P 可用作进度条变量
	fRN=false;
	CInteractionData tx;
	CInteractionData rx;
	while(false==fRN)
		//for(P=0;P<0x03;)//09,k
	{
		tx.Init();
		tx.buff[0] = 0x15;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;

		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=uart_RNEW[P][i];
		}
		Rx=tx.buff[0x1F];
		if(0x02==P)
		{
			Sum=0x00;
			for(i=0;i<0x0A;i++)
			{
				Sum+=tx.buff[0x11+i];
			}
			tx.buff[0x1B]=Sum;
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return;
		}
		else if (rx.buff[1] == 0x00)
		{
			// 			DspRead="Read OK 00";//每包发射都有返回，可以在非0时再显示
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
		}
		else
		{
			// 			DspRead="RENEW密码错误";//
			// 			SetDlgItemText(IDC_EDIT11, DspRead);
			// 			MessageBox("RENEW密码错误","Read",MB_OK);
			// 			return;
			pResult->hidResult= HIDResult_CANErr;
			return;
		}
		//------------------
		if(0x00!=Rx)
		{
			Sum=0x00;
			TS=rx.buff[0x1B];
			for(i=0;i<Rx-1;i++)
			{
				Sum+=rx.buff[i+0x11];
				tp[i]=rx.buff[i+0x11];
			}
			if(Sum!=TS)
			{
				// 				DspRead="校验错误1";//
				// 				SetDlgItemText(IDC_EDIT11, DspRead);
				// 				MessageBox("校验错误1","Read",MB_OK);
				// 				return;
				pResult->hidResult= HIDResult_CANErr;
				return;
			}
			//
			fSam=true;
			for(i=0;i<0x0A;i++)
			{
				if(tp[i]!=TA[i])
				{
					fSam=false;
				}
			}
			if(true==fSam)
			{
				// 				DspRead="RENEW完成";//
				// 				SetDlgItemText(IDC_EDIT11, DspRead);
				// 				MessageBox("RENEW完成","Read",MB_OK);
				fRN=true;
			}
			else
			{
				fSam=true;
				for(i=0;i<0x0A;i++)
				{
					if(tp[i]!=TB[i])
					{
						fSam=false;
					}
				}
				if(true==fSam)
				{
					// 					DspRead="RENEW无效";//
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					// 					MessageBox("RENEW无效","Read",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					fRN=true;
					//return;
				}
				else
				{
					// 					DspRead="RENEW未知错误";//
					// 					SetDlgItemText(IDC_EDIT11, DspRead);
					// 					MessageBox("RENEW未知错误","Read",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return;
				}
			}		
		}
		//
		P++;
		if(P>=0x03)
		{
			P=0x01;
		}
		//------------------
	}
}

byte* CHIDDevice::QuanDiu03( int mode,CProgressCtrl* pProgress,CInteractionData* pResult,CStatusBarCtrl* pStatusBar )
{
	// TODO: Add your control notification handler code here
	int i;
	CString str;//="都是进口垃圾地方";
	//------------
	const byte CAN_dtA[0x10]={0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//500k
	//const char CAN_dtB[0x10]={0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};//83.3k
	bool fDut=false;//波特率重试标识；每次点下按钮，仅重试1次后。

	const byte RDcmd[0x0A]={0x00,0x01,0x27,0x28,0x29,0x2A,0x2B,0x2C,0x2D,0x2E};

	//第1款--无错误动态字发生
	const byte CANm_A[0x0A][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},

		{0x01,0x03,0x80,0x00,0x00,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x81},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x11},//0x11,高1代表需要加入动态命令字
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第2款--无错误动态字发生
	const byte CANm_B[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x7E,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x81,高8代表握手也不保存数据

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x03,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第3款,第6款
	const byte CANm_C[0x06][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500K

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第4款--无错误动态字发生
	const byte CANm_D[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x92,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x00,0x62},//0x62,高6代表需要加入动态命令字,但不只保存第二包以及以后的数据
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x01},
	//	{0x01,0xC2,0x40,0x90,0x40,0x08,0x04,0x31,0x22,0x6F,0x00,0xFF,0xFF,0xFF,0x07,0x20},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x07,0x01},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第5款
	const byte CANm_E[0x07][0x10]={
		{0x00,0x0B,0xD0,0x42,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//83.3k

		{0x01,0x9C,0x00,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x11,0x00},//唤醒数据包

		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x0A,0x81},

		{0x01,0x03,0x80,0xBF,0xE0,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0x9C,0x00,0xBF,0xE0,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第7款
	const byte CANm_G[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//500k

		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0xAA,0x00},//唤醒数据包

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},//0x07,0X81

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x3E,0x02,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//第8款//第9款
	const byte CANm_H[0x07][0x10]={
		{0x00,0x01,0xD0,0x42,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
		{0x01,0xC2,0x40,0x00,0x00,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x07,0x00},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x02,0x10,0x03,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x81},

		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},//0x71,高7代表需要加入动态命令字,但不保存接收结果
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x06,0x31,0x01,0x00,0x22,0x6F,0x00,0xFF,0x00,0x71},
		{0x01,0xC2,0x40,0x90,0x40,0x08,0x30,0x08,0x28,0x00,0x00,0x00,0x00,0x00,0x00,0x02},

		{0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
	};
	//
	byte RDdiu[0x08][0x10]={
		{0x03,0x50,0x00,0x00,0x00,0x00,0x8F,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x30,0x01},
		{0x03,0x53,0x00,0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x00,0x00,0x00,0x09,0x00,0x01},
		{0x03,0x05,0x00,0x08,0x09,0x0A,0x0B,0x0C,0x0D,0x0E,0x0F,0x00,0x00,0x0A,0x00,0x01},
		{0x03,0x05,0x01,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x00,0x00,0x0A,0x00,0x01},
	//	{0x03,0x05,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x00,0x01},
	};

	//
	byte tmpRX[0x800];
	int m;
	int j;
	unsigned char P;
	unsigned char Rx;
	unsigned char cntR=0x00;
	unsigned char cnt1=0x00;

	unsigned char TMP[0x20][0x10];
	unsigned char Td[0x10]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00};
	unsigned char LPstart,LPend,LPcnt,Z,JC;
	unsigned char Ccnt;//每次加1的送数
	unsigned char k;

	unsigned char rdEEDT[0x09][0x06]={
		{0x0A,0x06,0x08,0x1A,0x00,0x00},//1--无错误
		{0x07,0x03,0x05,0x1C,0x00,0x00},//2--无错误
		{0x06,0x03,0x04,0x1C,0x01,0x03},//3--
		{0x07,0x03,0x05,0x1A,0x00,0x00},//4--无错误
		{0x07,0x03,0x05,0x1C,0x01,0x04},//5--
		{0x06,0x03,0x04,0x1C,0x01,0x03},//6--
		{0x07,0x03,0x05,0x1C,0x01,0x04},//7
		{0x07,0x03,0x05,0x1C,0x01,0x04},//8
		{0x07,0x03,0x05,0x1C,0x01,0x04},//9
	};
	unsigned char rdCK[0x08]={0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00};

		/*
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//1--无错误
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//2--无错误
		{0x03,0x00,0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00},//3--
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//4--无错误
		{0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//5--10,0E,71,01,00,22,70,01
		{0x03,0x00,0x10,0x0E,0x71,0x01,0x00,0x22,0x70,0x00},//6--
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//7
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//8
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},//9
	};*/

	k = rdEEDT[mode][0x00];
	LPstart = rdEEDT[mode][0x01];
	LPend = rdEEDT[mode][0x02];
	Z = rdEEDT[mode][0x03];//加入动态命令字的位置
	JC = rdEEDT[mode][0x05];//需要检查的行标

	bool fCK=false;
	bool fRS=false;
	bool fSAV=false;
	if(0x00!=rdEEDT[mode][0x04])
	{
		fCK=true;//可能有错的情况
	}
	else
	{
		fCK=false;
	}
	//	r=mode;
//-------------------------
	const byte TS[0x09][0x04]={
		{0x06,0x02,0x09,0x06},//1--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//3--
		{0x06,0x02,0x09,0x06},//4--
		{0x01,0x07,0x09,0x01},//5--
		{0x01,0x07,0x09,0x01},//6--
		{0x01,0x07,0x09,0x01},//7--
		{0x01,0x07,0x09,0x01},//2--
		{0x01,0x07,0x09,0x01},//2--
	};
	unsigned char AdL,AdC;
	unsigned char AsL,AsC;
	AdL=TS[mode][0];
	AdC=TS[mode][1];
	AsL=TS[mode][2];
	AsC=TS[mode][3];
	//
	bool fSame=false;
	//unsigned char readA[0x10],readB[0x10],readC[0x10],readD[0x10];
	unsigned char outBuf[0x800];
//-------------------------
	switch(mode)
	{
	//------
	case 0x00:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_A[j][i];
			}
		}
		break;
	//------
	case 0x01:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_B[j][i];
			}
		}
		break;
	//------
	case 0x02:
	case 0x05:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_C[j][i];
			}
		}
		break;
	//------
	case 0x03:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_D[j][i];
			}
		}
		break;
	//------
	case 0x04:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_E[j][i];
			}
		}
		break;
	//------
	case 0x06:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_G[j][i];
			}
		}
		break;
	//------
	case 0x07:
	case 0x08:
		for(j=0;j<k;j++)
		{
			for(i=0;i<0x10;i++)
			{
				TMP[j][i]=CANm_H[j][i];
			}
		}
		break;
	//------
	//------
	default:
		//MessageBox("未实现!!","Error",MB_OK);
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}	
	//--------------------
	str=_T("请把OBD线连接到车载端");
	if(MessageBox(str, _T("提示1"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}
	//--------------------
	//以下程序上面的按钮程序写了4遍，如果你做成模块，可以直接调用
	//
	LPcnt=0x00;
	Ccnt=0x00;
	m=0;
	cntR=0x00;
	CInteractionData tx;
	CInteractionData rx;
	for(P=0;P<k;)//P++
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=TMP[P][i];
		}
		//
		Rx=tx.buff[0x1F];
		if((0x10==(Rx&0xF0))||(0x70==(Rx&0xF0))||(0x60==(Rx&0xF0)))
		{
			tx.buff[Z] = RDcmd[LPcnt];
		}
		rdCK[0x07] = RDcmd[LPcnt];//检查备用
		//
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			cntR=0x00;
// 			DspRead="Read EEDT OK";
// 			SetDlgItemText(IDC_EDIT11, DspRead);
			//
			if((true==fCK)&&(JC==P))//需要检查而且行标一致
			{
				fRS=true;
				for(i=0;i<0x08;i++)
				{
					if(rdCK[i]!=rx.buff[i+0x10])
					{
						fRS=false;
					}
				}
			}
			else
			{
				fRS=true;//不要检测，置为真
				Ccnt=0x00;
			}
			if(true==fRS)
			{
				Ccnt=0x00;
				fSAV=true;//检查正确或不需检测
				P++;
				if((P>LPend)&&(LPcnt<0x09))
				{
					P=LPstart;
					LPcnt++;
				}
			}
			else
			{
				Ccnt++;
				fSAV=false;//检测错误
				if(Ccnt>0x14)
				{
					Ccnt=0x00;//检测错误后的重复发射超限后,强制设为有效记忆标识，
					for(i=0;i<0x10;i++)
					{
						rx.buff[i+0x10]=0x00;
					}
					fSAV=true;
					Rx=0x02;//需要记忆的两包数据。上面已经清零
					if(LPcnt<0x09)
					{
						P=LPstart;
						LPcnt++;
					}
					else
					{
						P=LPend+0x01;
					}
				}
			}
		}
		else
		{
			if(((0x00==mode)||(0x04==mode))&&(0x01==P))
			{
				if(false==fDut)
				{
					//第一次波特率尝试失败，不退出，载入500K数据继续测试
					//SetDlgItemText(IDC_EDIT11, DspRead);
					P=0x00;
					fDut=true;
					for(i=0;i<0x10;i++)
					{
						TMP[0][i]=CAN_dtA[i];
					}
				}
				else
				{
// 					DspRead="Read Error 83.3K";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
				}
			}
			else
			{
				if((Rx>0x00)&&(Rx<0x80))
				{
// 					DspRead="Read Error EEDT";
// 					SetDlgItemText(IDC_EDIT11, DspRead);
					//MessageBox("Read Error","Read",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
				}
				else
				{
					cntR++;
					if(cntR>0x05)
					{
// 						DspRead="Read Error EEDT 02";
// 						SetDlgItemText(IDC_EDIT11, DspRead);
						//MessageBox("Read Error","Read",MB_OK);
						pResult->hidResult= HIDResult_CANErr;
						return NULL;
					}
				}
			}
		}
		//------------------
		if(true==fSAV)
		{
			if((Rx>0x00)&&(Rx<0x60))
			{
				Rx=Rx&0x0F;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x10];
				}
				m+=(0x08*Rx);
			}
			//--
			if((Rx>0x61)&&(Rx<0x70))
			{
				Rx=Rx&0x0F;
				Rx--;
				for(i=0;i<0x08*Rx;i++)
				{
					tmpRX[m+i]=rx.buff[i+0x18];
				}
				m+=(0x08*Rx);
			}
			//---
		}
	}
	//------------------
	//char *outBuf;		//输出缓存
	//outBuf=new char[0x800+0x01];	//最大64M内存
	//memset(outBuf,0xFF,0x800);//0X00
	//outBuf[0x800]=0;
	for(i=0;i<0x800;i++)
	{
		outBuf[i]=0x00;
	}
	//---------
	for(i=0;i<0x0A;i++)
	{
		for(j=0;j<AdC;j++)
		{
			outBuf[i*0x10+j]=tmpRX[i*0x10+AdL+j];
		}
		for(j=0;j<AsC;j++)
		{
			outBuf[i*0x10+AdC+j]=tmpRX[i*0x10+AsL+j];
		}
	}
	//---------
	//for(i=0;i<m;i++)
	//{
	//	outBuf[i]=tmpRX[i];
	//}
	//------------------
	if(0x0F!=(outBuf[0x05]&0x0F))
	{
		MessageBox(_T("车载端未激活!!"),_T("Error"),MB_OK);
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}
	else
	{
		j=0x10*(outBuf[0x07]&0x07);
		j+=0x20;
		for(i=0;i<8;i++)
		{
			outBuf[0xF0+i]=outBuf[j+i];
		}
	}
	//------------------
	//此块是测试保存用途，正式开发时候去掉
/*	CFileDialog fileDlgS(FALSE);
	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
	fileDlgS.m_ofn.lpstrDefExt="BIN";
	if (IDOK==fileDlgS.DoModal())
	{
		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
		file.Write(outBuf,0x400);
		file.Close();
	}*/
	//delete []outBuf;
	//outBuf=NULL;
	//------------------
	//以上为重复4遍的模块结尾；

	
	//------------------
	//第1遍读车载端结束取数
	for(i=0;i<4;i++)
	{
		RDdiu[0x00][0x03+i]=outBuf[i];
	}
	//------------------
	//----
	str=_T("点确定后请及时把红外适配器插入钥匙孔");
	if(MessageBox(str, _T("提示2"),MB_YESNO) == IDYES)
	{
		//MessageBox("GOON!!","YES",MB_OK);
	}
	else
	{
		pResult->hidResult= HIDResult_CANErr;
		return NULL;
	}
	//------------------
//	char RDdiu[0x08][0x10]={
//		{0x03,0x50,0x00,0xC8,0x61,0x90,0x8F,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x30,0x01},
//		{0x03,0x53,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x09,0x20,0x01},
//		{0x03,0x05,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x20,0x01},
//		{0x03,0x05,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x20,0x01},
//		{0x03,0x05,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0A,0x20,0x01},
//	};
	//
	byte* IRdt=new byte[0x80*0x400];
	bool fFIN=false;
	unsigned int Ceer=0;
	unsigned int Ctry=0;
	unsigned char Cwait=0;
	bool fON=false;//等待红外头插入标识
	//---
	for(i=0;i<0x80*0x400;i++)
	{
		IRdt[i]=0x00;
	}
	P=0x00;
	j=0;
	while(false==fFIN)
	{
		tx.Init();
		tx.buff[0] = 0x14;
		tx.buff[1] = 0x55;	//主机-->设备 
		tx.buff[4]=0x20;
		for(i=0;i<0x10;i++)
		{
			tx.buff[i+0x10]=RDdiu[P][i];
		}
		rx = DeviceInteraction(tx);
		if (!rx.bOK)
		{
			pResult->hidResult= HIDResult_USBError;
			return NULL;
		}
		else if (rx.CheckDataList() == false)
		{
			pResult->hidResult= HIDResult_RxError;
			return NULL;
		}
		else if (rx.buff[1] == 0x00)
		{
			switch(P)
			{
				//------
				case 0x00:
					if(0x63==rx.buff[0x11])
					{
						for(i=0;i<0x09;i++)
						{
							IRdt[0x80*j+0x20*P+0x10+i]=rx.buff[0x11+i];
						}
					}
					else
					{
						MessageBox(_T("红外回复错误!!"),_T("Read"),MB_OK);
					}
					fON=true;
					break;
				//------
				case 0x01:
				case 0x02:
				case 0x03:
			//	case 0x04:
					if(0x68==rx.buff[0x11])
					{
						for(i=0;i<0x0A;i++)
						{
							IRdt[0x80*j+0x20*P+0x10+i]=rx.buff[0x11+i];
						}
					}
					else
					{
						//MessageBox("红外回复错误!!","Read",MB_OK);
						pResult->hidResult= HIDResult_CANErr;
						return NULL;
					}
					break;
				//------
				default:
					//MessageBox("未知错误1!","Error",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return NULL;
			}
			//
			for(i=0;i<0x0A;i++)
			{
				IRdt[0x80*j+0x20*P+i]=RDdiu[P][i+0x01];
			}
			//
			P++;
			if(P>=0x04)
			{
				P=0x00;
				j++;
				if(j>=0x400)//0x01
				{
					fFIN=true;
				}
			}
		}
		else
		{
			switch(P)
			{
				//------
				case 0x00:
					if(false==fON)
					{
						Ctry++;
						if(Ctry>0x100)
						{
							//MessageBox("红外适配器插入 超时!!","Read",MB_OK);
							pResult->hidResult= HIDResult_CANErr;
							return NULL;
						}
					}
					else
					{
						//MessageBox("接收超时!!","Read",MB_OK);
						fFIN=true;
					}
					break;
				//--------
				case 0x01:
				case 0x02:
				case 0x03:
			//	case 0x04:
					//MessageBox("接收超时!!","Read",MB_OK);
					fFIN=true;
					//return;
					break;
				//------
				//------
				default:
					//MessageBox("未知错误2!","Error",MB_OK);
					pResult->hidResult= HIDResult_CANErr;
					return NULL;			
			}
		}

	}
	//此块是测试保存用途，正式开发时候去掉
// 	CFileDialog fileDlgS(FALSE);
// 	fileDlgS.m_ofn.lpstrTitle="保存为文件:*.BIN";
// 	fileDlgS.m_ofn.lpstrFilter="Text Files(*.BIN)\0*.BIN\0All Files(*.*)\0*.*\0\0";
// 	fileDlgS.m_ofn.lpstrDefExt="BIN";
// 	if (IDOK==fileDlgS.DoModal())
// 	{
// 		CFile file(fileDlgS.GetFileName(),CFile::modeCreate|CFile::modeWrite);
// 		file.Write(IRdt,0x80*0x400);//0x40*0x400
// 		file.Close();
// 	}
	return IRdt;
	//------------------
}


// CHIDDevice 消息处理程序


